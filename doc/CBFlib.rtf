{\rtf1\mac\deff2 {\fonttbl{\f2\froman New York;}{\f3\fswiss Geneva;}{\f4\fmodern Monaco;}{\f13\fnil Zapf Dingbats;}{\f15\fnil N Helvetica Narrow;}{\f16\fnil Palatino;}{\f18\fnil Zapf Chancery;}{\f20\froman Times;}{\f21\fswiss Helvetica;}{\f22\fmodern Courier;}{\f23\ftech Symbol;}{\f34\fnil New Century Schlbk;}{\f200\fnil LockFont;}{\f201\fnil Mishawaka Bold;}{\f256\fnil Mishawaka;}{\f1109\fnil Trebuchet MS;}{\f2001\fnil Arial;}{\f2002\fnil Charcoal;}{\f2003\fnil Capitals;}{\f2004\fnil Sand;}{\f2005\fnil Courier New;}{\f2006\fnil Techno;}{\f2010\fnil Times New Roman;}{\f2305\fnil Textile;}{\f2307\fnil Gadget;}{\f2421\fnil Impact;}{\f2515\fnil MT Extra;}{\f3138\fnil Bernhard Modern Roman;}{\f4019\fnil Myriad Roman;}{\f4020\fnil Myriad Bold;}{\f4021\fnil Myriad Italic;}{\f4022\fnil Myriad BoldItalic;}{\f4513\fnil Comic Sans MS;}{\f4538\fnil Arial Black;}{\f5673\fnil Tekton Bold;}{\f7092\fnil Monotype.com;}{\f7203\fnil Verdana;}{\f10840\fnil Klang MT;}{\f10890\fnil Script MT Bold;}{\f10897\fnil Old English Text MT;}{\f10909\fnil New Berolina MT;}{\f10957\fnil Bodoni MT Ultra Bold;}{\f10967\fnil Arial MT Condensed Light;}{\f12163\fnil Paisley ICG 01;}{\f12164\fnil Paisley ICG 01 Alt;}{\f12165\fnil Paisley ICG 02;}{\f12166\fnil Paisley ICG 02 Alt;}{\f12171\fnil Georgia;}{\f12201\fnil UltraCondensedSansTwo;}{\f12241\fnil Decotura ICG;}{\f12242\fnil Decotura ICG Inline;}{\f12257\fnil Boca Raton ICG;}{\f12262\fnil Boca Raton ICG Solid;}{\f12264\fnil Fajita ICG Mild;}{\f12265\fnil Fajita ICG Picante;}{\f12282\fnil Wonton ICG;}{\f13102\fnil Tekton;}{\f13217\fnil NuptialScript;}{\f13221\fnil Trajan Bold;}{\f13222\fnil Trajan;}{\f13226\fnil Copperplate33bc;}{\f13232\fnil Copperplate31ab;}{\f14213\fnil Webdings;}{\f14258\fnil UltraCondensedSansOne;}{\f14309\fnil Chilada ICG Uno;}{\f14310\fnil Chilada ICG Dos;}{\f14311\fnil Chilada ICG Tres;}{\f14312\fnil Chilada ICG Cuatro;}{\f14358\fnil Litterbox ICG;}{\f14361\fnil Whimsy ICG;}{\f14362\fnil Whimsy ICG Bold;}{\f14363\fnil Whimsy ICG Heavy;}{\f14539\fnil Franklin Gothic No.2;}{\f14541\fnil Franklin Gothic Condensed;}{\f14562\fnil AGaramond;}{\f14563\fnil AGaramond Italic;}{\f14570\fnil AGaramond BoldItalic;}{\f14571\fnil AGaramond Bold;}{\f14612\fnil VAG Rounded Thin;}{\f14613\fnil VAG Rounded Light;}{\f14614\fnil VAG Rounded Bold;}{\f14615\fnil VAG Rounded Black;}{\f14779\fnil OCRA;}{\f14898\fnil Stencil;}{\f14913\fnil BI Prestige Elite BoldSlanted;}{\f14914\fnil B Prestige Elite Bold;}{\f14915\fnil I Prestige Elite Slanted;}{\f14916\fnil Prestige Elite;}{\f14926\fnil Park Avenue;}{\f14944\fnil Goudy;}{\f15011\fnil Gill Sans Condensed Bold;}{\f15089\fnil Minion Web;}{\f15164\fnil Alleycat ICG;}{\f15165\fnil Alleycat ICG Bold;}{\f15170\fnil Saturday Sans ICG;}{\f15171\fnil Saturday Sans ICG Bold;}{\f16383\fnil Chicago;}{\f32525\fnil VT100;}{\f32526\fnil TTYFont;}}{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;}{\stylesheet{\s243\tqc\tx4320\tqr\tx8640 \fs20 \sbasedon0\snext243 footer;}{\s244\tqc\tx4320\tqr\tx8640 \fs20 \sbasedon0\snext244 header;}{\fs20 \sbasedon222\snext0 Normal;}}{\info{\title CBFlib}{\subject An API for CBF/imgCIF}{\author Paul J. Ellis,Herbert J.  Bernstein}{\*\verscomm 0.7.2}}\widowctrl\ftnbj\fracwidth \sectd \sbknone\pgnlcrm\linemod0\linex0\cols1\endnhere\titlepg {\footer \pard\plain \s243\tqc\tx4320\tqr\tx8640 \fs20 {\f20 CBFlib 0.7\tab \tab Page - }{\f20 \chpgn }\par }\pard\plain \qc \fs20 {{\pict\macpict\picw212\pich106\picscaled 11be00000000009f0134001102ff0c00ffffffff000000000000000001340000009f000000000000001e001afcfcf3f305050001000a00000000009f0134000aaa55aa55aa55aa550074008e006600e8007d00ff006600f4006900f2006700f0006b00ef006a00ec006d00ed006e00ea007000eb007200e8007300eb007600e9007700ed007900ec007900ef007c00f0007a00f2007d00f4007a00f5007c00f8007900f8007900fb007700fb007600fe007400fc007200ff007000fc006e00fe006d00fb006a00fb006b00f9006800f8006900f6006600f4001a8080d5d5f4f40070008e006600e8007d00ff006600f4006900f2006700f0006b00ef006a00ec006d00ed006e00ea007000eb007200e8007300eb007600e9007700ed007900ec007900ef007c00f0007a00f2007d00f4007a00f5007c00f8007900f8007900fb007700fb007600fe007400fc007200ff007000fc006e00fe006d00fb006a00fb006b00f9006800f8006900f6006600f4001afcfcf3f30505000a77dd77dd77dd77dd0074008e005400cf007f00fb005400e5005900e2005600dd005c00dc005b00d6006100d7006200d2006700d5006a00cf006d00d4007200d1007300d7007800d6007800dc007d00dd007a00e2007f00e5007a00e9007d00ee007800ef007800f4007300f3007200f9006d00f6006a00fb006700f6006200f9006100f3005b00f4005c00ef005700ee005a00e9005400e5001a4141c0c0efef0070008e005400cf007f00fb005400e5005900e2005600dd005c00dc005b00d6006100d7006200d2006700d5006a00cf006d00d4007200d1007300d7007800d6007800dc007d00dd007a00e2007f00e5007a00e9007d00ee007800ef007800f4007300f3007200f9006d00f6006a00fb006700f6006200f9006100f3005b00f4005c00ef005700ee005a00e9005400e5001afcfcf3f30505000affeeffbbffeeffbb0074008e002d00a2008000f5002d00cb003700c5003100bc003c00ba003a00af004500b1004700a7005100ac005700a2005d00ac006600a6006900b1007300af007200ba007c00bc007700c5008000cb007700d1007d00da007200dd007300e8006a00e5006700f1005e00eb005700f5005100ec004700f2004500e5003a00e8003c00dd003200db003700d2002d00cb001a2121b5b5ecec0070008e002d00a2008000f5002d00cb003700c5003100bc003c00ba003a00af004500b1004700a7005100ac005700a2005d00ac006600a6006900b1007300af007200ba007c00bc007700c5008000cb007700d1007d00da007200dd007300e8006a00e5006700f1005e00eb005700f5005100ec004700f2004500e5003a00e8003c00dd003200db003700d2002d00cb001afcfcf3f30505000affffffffffffffff0074008e00000045009e00e3000000950011008900070077001c00720019005f002c00610031004e00420058004f0045005c0057006d004c007200610086005e0083007200970077008d0088009e0095008d00a0009900b2008400b6008600ca007300c7006e00dc005c00d0004f00e3004300d1003200de002d00c7001900cb001c00b7000900b3001200a100000095001a0202ababeaea0070008e00000045009e00e3000000950011008900070077001c00720019005f002c00610031004e00420058004f0045005c0057006d004c007200610086005e0083007200970077008d0088009e0095008d00a0009900b2008400b6008600ca007300c7006e00dc005c00d0004f00e3004300d1003200de002d00c7001900cb001c00b7000900b3001200a100000095001afcfcf3f30505000add77dd77dd77dd77007400220034005b006b0076003f007600340065004e005b006b006500610076003f0076001a000000000000007000220034005b006b0076003f007600340065004e005b006b006500610076003f0076001afcfcf3f3050500740026002c0075007400b2002c0094004000750061007500740094006100b2003f00b2002c0094001a00000000000000700026002c0075007400b2002c0094004000750061007500740094006100b2003f00b2002c0094001afcfcf3f30505000affffffffffffffff00740022003400b2006b00cd003f00b2003400c4004e00cd006b00c4006100b2003f00b2001a00000000000000700022003400b2006b00cd003f00b2003400c4004e00cd006b00c4006100b2003f00b2001afcfcf3f30505000add77dd77dd77dd770074002200190094004000c5002e009400190094002000b2003600c5004000b3002e0094001a0000000000000070002200190094004000c5002e009400190094002000b2003600c5004000b3002e0094001afcfcf3f30505000aaa55aa55aa55aa55007400220019006400400095002e009500190095002000780036006400400076002e0095001a000000000000007000220019006400400095002e009500190095002000780036006400400076002e0095001afcfcf3f30505000affffffffffffffff0074002200600093008700c40073009300870093008100b1006b00c4006000b200730093001a0000000000000070002200600093008700c40073009300870093008100b1006b00c4006000b200730093001afcfcf3f30505007400220060006300870094007300940087009400810077006b00630060007500730094001a000000000000007000220060006300870094007300940087009400810077006b00630060007500730094001afcfcf3f3050500340017002f00850094001a00000000d4d40038001affffffffffff000a0000000000000000003400290038003c0042001a00000000d4d40038001affffffffffff00340029004a003c0055001a00000000d4d40038001affffffffffff00340044004a00580055001a00000000d4d40038001affffffffffff00340044005d00580067001a00000000d4d40038001affffffffffff00340060004a00730055001a00000000d4d40038001affffffffffff00340060005d00730067001a00000000d4d40038001affffffffffff00340044006f00580079001a00000000d4d40038001affffffffffff00340060007800730082001a00000000d4d40038001afcfcf3f30505000aaa55aa55aa55aa550074008e006500e8007c00ff006500f4006800f2006600f0006a00ef006900ec006c00ed006d00ea006f00eb007100e8007200eb007500e9007600ed007800ec007800ef007b00f0007900f2007c00f4007900f5007b00f8007800f8007800fb007600fb007500fe007300fc007100ff006f00fc006d00fe006c00fb006900fb006a00f9006700f8006800f6006500f4001a8080d5d5f4f40070008e006500e8007c00ff006500f4006800f2006600f0006a00ef006900ec006c00ed006d00ea006f00eb007100e8007200eb007500e9007600ed007800ec007800ef007b00f0007900f2007c00f4007900f5007b00f8007800f8007800fb007600fb007500fe007300fc007100ff006f00fc006d00fe006c00fb006900fb006a00f9006700f8006800f6006500f4001afcfcf3f30505000a77dd77dd77dd77dd0074008e005400cf007f00fb005400e5005900e2005600dd005c00dc005b00d6006100d7006200d2006700d5006a00cf006d00d4007200d1007300d7007800d6007800dc007d00dd007a00e2007f00e5007a00e9007d00ee007800ef007800f4007300f3007200f9006d00f6006a00fb006700f6006200f9006100f3005b00f4005c00ef005700ee005a00e9005400e5001a4141c0c0efef0070008e005400cf007f00fb005400e5005900e2005600dd005c00dc005b00d6006100d7006200d2006700d5006a00cf006d00d4007200d1007300d7007800d6007800dc007d00dd007a00e2007f00e5007a00e9007d00ee007800ef007800f4007300f3007200f9006d00f6006a00fb006700f6006200f9006100f3005b00f4005c00ef005700ee005a00e9005400e5001afcfcf3f30505000affeeffbbffeeffbb0074008e002d00a2008000f5002d00cb003700c5003100bc003c00ba003a00af004500b1004700a7005100ac005700a2005d00ac006600a6006900b1007300af007200ba007c00bc007700c5008000cb007700d1007d00da007200dd007300e8006a00e5006700f1005e00eb005700f5005100ec004700f2004500e5003a00e8003c00dd003200db003700d2002d00cb001a2121b5b5ecec0070008e002d00a2008000f5002d00cb003700c5003100bc003c00ba003a00af004500b1004700a7005100ac005700a2005d00ac006600a6006900b1007300af007200ba007c00bc007700c5008000cb007700d1007d00da007200dd007300e8006a00e5006700f1005e00eb005700f5005100ec004700f2004500e5003a00e8003c00dd003200db003700d2002d00cb001afcfcf3f30505000affffffffffffffff0074008e00000045009e00e3000000950011008900070077001c00720019005f002c00610031004e00420058004f0045005c0057006d004c007200610086005e0083007200970077008d0088009e0095008d00a0009900b2008400b6008600ca007300c7006e00dc005c00d0004f00e3004300d1003200de002d00c7001900cb001c00b7000900b3001200a100000095001a0202ababeaea0070008e00000045009e00e3000000950011008900070077001c00720019005f002c00610031004e00420058004f0045005c0057006d004c007200610086005e0083007200970077008d0088009e0095008d00a0009900b2008400b6008600ca007300c7006e00dc005c00d0004f00e3004300d1003200de002d00c7001900cb001c00b7000900b3001200a100000095001afcfcf3f30505000add77dd77dd77dd77007400220034005b006b0076003f007600340065004e005b006b006500610076003f0076001a000000000000007000220034005b006b0076003f007600340065004e005b006b006500610076003f0076001afcfcf3f3050500740026002b0075007300b2002b0094003f00750060007500730094006000b2003e00b2002b0094001a00000000000000700026002b0075007300b2002b0094003f00750060007500730094006000b2003e00b2002b0094001afcfcf3f30505000affffffffffffffff00740022003300b2006a00cd003e00b2003300c4004d00cd006a00c4006000b2003e00b2001a00000000000000700022003300b2006a00cd003e00b2003300c4004d00cd006a00c4006000b2003e00b2001afcfcf3f30505000add77dd77dd77dd770074002200180093003f00c4002d009300180093001f00b1003500c4003f00b2002d0093001a0000000000000070002200180093003f00c4002d009300180093001f00b1003500c4003f00b2002d0093001afcfcf3f30505000aaa55aa55aa55aa550074002200180064003f0095002d009500180095001f007800350064003f0076002d0095001a0000000000000070002200180064003f0095002d009500180095001f007800350064003f0076002d0095001afcfcf3f30505000affffffffffffffff00740022005f0093008600c40072009300860093008000b1006a00c4005f00b200720093001a00000000000000700022005f0093008600c40072009300860093008000b1006a00c4005f00b200720093001afcfcf3f3050500740022005f006300860094007200940086009400800077006a0063005f007500720094001a00000000000000700022005f006300860094007200940086009400800077006a0063005f007500720094001afcfcf3f3050500340016002f00840094001a00000000d4d40038001affffffffffff000a0000000000000000003400280038003b0042001a00000000d4d40038001affffffffffff00340028004a003b0055001a00000000d4d40038001affffffffffff00340043004a00570055001a00000000d4d40038001affffffffffff00340043005d00570067001a00000000d4d40038001affffffffffff0034005f004a00720055001a00000000d4d40038001affffffffffff0034005f005d00720067001a00000000d4d40038001affffffffffff00340043006f00570079001a00000000d4d40038001affffffffffff0034005f007800720082001a00000000d4d4003800a10064001250504e54001120000948656c766574696361001afcfcf3f30505002c000c00150948656c7665746963610003001500040100000d005d002e000400000000002b0673064342466c696200001adddd080806060028006f0001064342466c69620000ff}}{\f20 \par }\pard \qc {\f20 \par }{\b\f20 An API for CBF/imgCIF\par Crystallographic Binary Files with ASCII Support\par }{\f20 \par Version 0.7.2\par 22 April 2001\par \par \par \par by\par \par }\pard \qc {\b\f20\fs28 Paul J. Ellis}{\f20 \par }\pard \qc {\f20 Stanford Synchrotron Radiation Laboratory\par ellis@ssrl.slac.stanford.edu \par \par and\par \par }\pard \qc {\b\f20\fs28 Herbert J. Bernstein}{\f20 \par }\pard \qc {\f20 Bernstein + Sons\par yaya@bernstein-plus-sons.com \par }\pard {\f20 \par \par \par \par \par \par }\pard {\b\f20 \page }{\f20 Before using this software, please read the following notices for important disclaimers and the IUCr Policy on the Use of the Crystallographic Information File (CIF) and for other important information. \par }\pard {\f20 \par \par \par }\pard \qc {\b\f20 CBFlib Notices}{\f20 \par }\pard {\f20 \par The following notice applies to this work as a whole and to the works included within it: \par \par }\pard {\f20 \tab Creative endeavors depend on the lively exchange of ideas. There are laws and customs which establish rights and responsibilities for authors and the users of what authors create. This notice is not intended to prevent you from using the software and documents in this package, but to ensure that there are no  misunderstandings about terms and conditions of such use.   Please read the following notice carefully. If you do not understand any portion of this notice, please seek appropriate professional legal advice before making use of the software and documents included in this software package. In addition to whatever other steps you may be obliged to take to respect the intellectual property rights of the various parties involved, if you do make use of the software and documents in this package, please give credit where credit is due by citing this package, its authors and the URL or other source from which you obtained it, or equivalent primary references in the literature with the same authors. \par }\pard {\f20 \par }\pard {\f20 \tab Some of the software and documents included within this software package are the intellectual property of various parties, and placement in this package does not in any way imply that any such rights have in any way been waived or diminished. \par }\pard {\f20 \par }\pard {\f20 \tab With respect to any software or documents for which a copyright exists, }{\b\f20 ALL RIGHTS ARE RESERVED TO THE OWNERS OF SUCH COPYRIGHT. }{\f20 \par }\pard {\f20 \par }\pard {\f20 \tab Even though the authors of the various documents and software found here have made a good faith effort to ensure that the documents are correct and that the software performs according to its documentation, and we would greatly appreciate hearing of any problems you may encounter, the programs and documents any files created by the programs are provided **AS IS** without any warranty as to correctness, merchantability or fitness for any particular or general use.   }{\b\f20 THE RESPONSIBILITY FOR ANY ADVERSE CONSEQUENCES FROM THE USE OF PROGRAMS OR DOCUMENTS OR ANY FILE OR FILES CREATED BY USE OF THE PROGRAMS OR DOCUMENTS LIES SOLELY WITH THE USERS OF THE PROGRAMS OR DOCUMENTS OR FILE OR FILES AND NOT WITH AUTHORS OF THE PROGRAMS OR DOCUMENTS.}{\f20  \par }\pard {\f20 \par \par }\pard \qc {\f20 \page }{\b\f20 The IUCr Policy for the Protection and the Promotion of the STAR File and CIF Standards for Exchanging and Archiving Electronic Data. }{\f20 \par }\pard {\f20\fs18 \par }\pard {\b\f20 Overview:  }{\f20 The Crystallographic Information File (CIF)[1] is a standard for information interchange promulgated by the International Union of Crystallography (IUCr). CIF (Hall, Allen & Brown, 1991) is the recommended method for submitting publications to Acta Crystallographica Section C and reports of crystal structure determinations to other sections of Acta Crystallographica and many other journals. The syntax of a CIF is a subset of the more general STAR File[2] format. The CIF and STAR File approaches are used increasingly in the structural sciences for data exchange and archiving, and are having a significant influence on these activities in other fields. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\b\f20 Statement of intent:  }{\f20 The IUCr's interest in the STAR File is as a general data interchange standard for science, and its interest in the CIF, a conformant derivative of the STAR File, is as a concise data exchange and archival standard for crystallography and structural science. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\b\f20 Protection of the standards}{\f20 :  To protect the STAR File and the CIF as standards for interchanging and archiving electronic data, the IUCr, on behalf of the scientific community, }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 \tab \bullet  holds the copyrights on the standards themselves, }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 \tab \bullet  owns the associated trademarks and service marks, and }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 \tab \bullet  holds a patent on the STAR File. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 These intellectual property rights relate solely to the interchange formats, not to the data contained therein, nor to the software used in the generation, access or manipulation of the data. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\b\f20 Promotion of the standards}{\f20 :  The sole requirement that the IUCr, in its protective role, imposes on software purporting to process STAR File or CIF data is that the following conditions be met prior to sale or distribution. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard \li700 {\f20 \bullet  Software claiming to read files written to either the STAR File or the CIF standard must be able to extract the pertinent data from a file conformant to the STAR File syntax, or the CIF syntax, respectively. }{\f20\fs14 \par }\pard \li700 {\f20\fs14 \par }\pard \li700 {\f20 \bullet  Software claiming to write files in either the STAR File, or the CIF, standard must produce files that are conformant to the STAR File syntax, or the CIF syntax, respectively. }{\f20\fs14 \par }\pard \li700 {\f20\fs14 \par }\pard \li700 {\f20 \bullet  Software claiming to read definitions from a specific data dictionary approved by the IUCr must be able to extract any pertinent definition which is conformant to the dictionary definition language (DDL)[3] associated with that dictionary. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 The IUCr, through its Committee on CIF Standards, will assist any developer to verify that software meets these conformance conditions. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\b\f20 Glossary of terms }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 [1] CIF:  is a data file conformant to the file syntax defined at http://www.iucr.org/iucr-top/cif/spec/index.html }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 [2] STAR File:  is a data file conformant to the file syntax defined at http://www.iucr.org/iucr-top/cif/spec/star/index.html }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 [3] DDL:  is a language used in a data dictionary to define data items in terms of "attributes". Dictionaries currently approved by the IUCr, and the DDL versions used to construct these dictionaries, are listed at http://www.iucr.org/iucr-top/cif/spec/ddl/index.html }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\b\f20 Last modified: }{\f20 30 September 2000 \par IUCr Policy Copyright (C) 2000 International Union of Crystallography \par }\pard \qc {\b\f20\fs18 \page }{\b\f20 CBFlib V0.1 Notice}{\f20 \par }\pard {\f20 \par The following Diclaimer Notice applies to CBFlib V0.1, from which this version is derived. \par \par }\pard {\f20 \tab The items furnished herewith were developed under the sponsorship of the U.S. Government. Neither the U.S., nor the U.S. D.O.E., nor the Leland Stanford Junior University, nor their employees, makes any warranty, express or implied, or assumes any liability or responsibility for accuracy,  completeness or usefulness of any information, apparatus, product or process disclosed, or represents that its use will not infringe privately-owned rights. Mention of any product, its manufacturer, or suppliers shall not, nor is it intended to, imply approval, disapproval, or fitness for any particular use. The U.S. and the University at all times retain the right to use and disseminate the furnished items for any purpose whatsoever.\par }\pard {\f20 \par Notice 91 02 01\par \par \par \par \par }\pard \qc {\b\f20 CIFPARSE Notice}{\f20 \par }\pard {\f20 \par }\pard {\f20 Portions of this software are loosely based on the CIFPARSE software package from the NDB at Rutgers University (see http://ndbserver.rutgers.edu/NDB/mmcif/software). CIFPARSE is part of the NDBQUERY application, a program component of the Nucleic Acid Database Project [ H. M. Berman, W. K. Olson, D. L. Beveridge, J. K. Westbrook, A. Gelbin, T. Demeny, S. H. Shieh, A. R. Srinivasan, and B. Schneider. (1992). The Nucleic Acid Database: A Comprehensive Relational Database of Three-Dimensional Structures of Nucleic Acids. Biophys J., 63, 751-759.], whose cooperation is gratefully acknowledged, especially in the form of design concepts created by J. Westbrook. \par }\pard {\f20 \par Please be aware of the following notice in the CIFPARSE API: \par \par }\pard {\f20        This software is provided }{\b\f20 WITHOUT WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE OR ANY OTHER WARRANTY, EXPRESS OR IMPLIED. RUTGERS MAKE NO REPRESENTATION OR WARRANTY THAT THE SOFTWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT OR OTHER PROPRIETARY RIGHT.}{\f20  \par }\pard {\f20 \par \par }\pard \qc {\f20 \page }{\b\f20 MPACK Notice}{\f20 \par }\pard {\f20 \par }\pard {\f20 Portions of this library are adapted from the "mpack/munpack version 1.5" routines, written by John G. Myers.  Mpack and munpack are utilities for encoding and decoding (respectively) binary files in MIME (Multipurpose\par }\pard {\f20 Internet Mail Extensions) format mail messages. The mpack software used is (C) Copyright 1993,1994 by Carnegie Mellon University, All Rights Reserved, and is subject to the following notice: \par }\pard {\f20 \par }\pard {\f20        Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Carnegie Mellon University not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission. Carnegie Mellon University makes no representations about the suitability of this software for any purpose. It is provided "as is" without express or implied warranty.   }{\b\f20 CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.}{\f20  \par }\pard {\f20 \par \par }\pard \qc {\b\f20 MD5 Notice}{\f20 \par }\pard {\f20 \par }\pard {\f20 The following notice applies to the message digest software in md5.h and md5.c which are optionally used by this library. To that extent, this library is a work "derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm". \par }\pard {\f20 \par }\pard {\f20 The software in md5.h and md5.c is Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All rights reserved, and is subject to the following notice: \par }\pard {\f20 \par }\pard {\f20        License to copy and use this software is granted provided that it is identified as the "RSA Data Security, Inc. MD5 Message-Digest Algorithm" in all material mentioning or referencing this software or this function.   License is also granted to make and use derivative works provided that such works are identified as "derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm" in all material mentioning or referencing the derived work.   RSA Data Security, Inc. makes no representations concerning either the merchantability of this software or the suitability of this software for any particular purpose. It is provided "as is" without express or implied warranty of any kind.   These notices must be retained in any copies of any part of this documentation and/or software. \par }\pard {\f20 \par }\pard \qc {\b\f20 \page Version History}{\f20 \par }\pard {\f20 \par \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx1000\clshdng0\cellx2080\clshdng0\cellx2953\clshdng0\cellx8353\pard \intbl {\b\f20 Version \cell Date\cell }\pard \intbl {\b\f20 By\cell }\pard \intbl {\b\f20 Description\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx784\clshdng0\cellx2080\clshdng0\cellx2953\clshdng0\cellx8353\pard \intbl {\f20 0.1\cell }\pard \intbl {\f20 Apr. 1998\cell }\pard \intbl {\f20 PJE\cell }\pard \intbl {\f20 This was the first CBFlib release. It supported binary CBF files using binary strings. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 0.2\cell }\pard \intbl {\f20 Aug. 1998\cell }\pard \intbl {\f20 HJB\cell }\pard \intbl {\f20 This release added ascii imgCIF support using MIME-encoded binary sections, added the option of MIME headers for the binary strings was well. MIME code adapted from mpack 1.5. Added hooks needed for \par }\pard \intbl {\f20 DDL1-style names without categories. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 0.3\cell }\pard \intbl {\f20 Sep. 1998\cell }\pard \intbl {\f20 PJE\cell }\pard \intbl {\f20 This release cleaned up the changes made for version 0.2, allowing multi-threaded use of the code, and removing dependence on the mpack package. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 0.4\cell }\pard \intbl {\f20 Nov. 1998\cell }\pard \intbl {\f20 HJB\cell }\pard \intbl {\f20 This release merged much of the message digest code into the general file reading and writing to reduce the number of passes. More consistency checking between the MIME header and the binary header was introduced. The size in the MIME header was adjusted to agree with the version 0.2 documentation. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 0.5\cell }\pard \intbl {\f20 Dec. 1998\cell }\pard \intbl {\f20 PJE\cell }\pard \intbl {\f20 This release greatly increased the speed of processing by allowing for deferred digest evaluation. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 0.6\cell }\pard \intbl {\f20 Jan. 1999\cell }\pard \intbl {\f20 HJB\cell }\pard \intbl {\f20 This release removed the redundant information (binary id, size, compression id) from a binary header when there is a MIME header, removed the unused repeat argument, and made the memory allocation for buffering and tables with many rows sensitive to the current memory allocation already used. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 0.6.1\cell }\pard \intbl {\f20 Feb. 2001\cell }\pard \intbl {\f20 HP (per HJB)\cell }\pard \intbl {\f20 This release fixed a memory leak due to misallocation by size of cbf_handle instead of cbf_handle_struct \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 0.7\cell }\pard \intbl {\f20 Mar. 2001\cell }\pard \intbl {\f20 PJE\cell }\pard \intbl {\f20 This release added high-level instructions based on the imgCIF dictionary version 1.1. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 0.7.1\cell }\pard \intbl {\f20 Mar. 2001\cell }\pard \intbl {\f20 PJE\cell }\pard \intbl {\f20 The high-level functions were revised to permit future expansion to files with multiple images. \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx784\clshdng0\cellx2080\clshdng0\cellx2953\clshdng0\cellx8353\pard \intbl {\f20 0.7.2\cell }\pard \intbl {\f20 Apr. 2001\cell }\pard \intbl {\f20 HJB\cell }\pard \intbl {\f20 Fixup for latest dictionary and to make documentation current \cell }\pard \intbl {\f20 \row }\pard {\b\f20 \par \par \par \par }\pard \qc {\b\f20 Known Problems}{\f20 \par }\pard {\f20 \par }\pard {\f20 This version does not have support for byte-offset or predictor compression. Code is needed to support array sub-sections.  \par }\pard {\f20 \par }\pard {\b\f20 \page }{\b\f20\fs28 Foreword}{\f20 \par }\pard {\f20 \par \par }\pard {\f20 In order to work with CBFlib, you need the source code, in the form of a \ldblquote gzipped\rdblquote  tar, CBFlib.tar.gz. Uncompress this file. Place it in an otherwise empty directory, and unpack it with tar. You will also need Paul Ellis's sample MAR345 image, example.mar2300, as sample data. This file can also be found at http://biosg1.slac.stanford.edu/biosg1-users/ellis/Public/. Place that file in the top level directory (one level up from the source code).   Adjust the definition of CC in Makefile to point to your C compiler, and then \par }\pard {\f20 \par }\pard \li720 {\b\f20 make all \par make tests \par }\pard {\f20 \par This release has been tested on an SGI under IRIX 6.4 and on a PowerPC under Linux-ppc 2.1.24. \par \par }\pard {\f20 We have included examples of CBF/imgCIF files produced by CBFlib, an updated version of John Westbrook's DDL2-compliant CBF Extensions Dictionary, and of Andy Hammersley's CBF definition, updated to become a DRAFT CBF/ImgCIF DEFINITION. \par }\pard {\f20 \par }\pard {\f20 This is just a proposal. Please be careful about basing any code on this until and unless there has been a general agreement. \par \sect }\sectd \sbkodd\pgnlcrm\linemod0\linex0\cols1\endnhere {\footer \pard\plain \s243\tqc\tx4320\tqr\tx8640 \fs20 {\f20 CBFlib 0.7\tab \tab Page - }{\f20 \chpgn }{\f20 \par }}\pard\plain \fs20 {\f20 \par }\pard \qc {\b\f20\fs28 Contents}{\f20 \par }\pard {\f20 \par }\pard \tx1080\tqr\tx7560 {\f20 1. Introduction \tab 1\par \par 2. Function descriptions \tab 3\par \par \tab 2.1 General description \par \tab 2.1.1 CBF handles \par }{\b\f20 \tab }{\f20 2.1.2 CBF goniometer handles\par }{\b\f20 \tab }{\f20 2.1.3 CBF detector handles\par \tab 2.1.4 Return values\par \par \tab 2.2 Reading and writing files containing binary sections \par \tab 2.2.1 Reading binary sections \par \tab 2.2.2 Writing binary sections \par \tab 2.2.3 Summary of reading and writing files containing binary sections \par \par \tab 2.3 Low-level function prototypes \tab 7\par \par \tab 2.3.1 }{\b\f20 cbf_make_handle}{\f20  \par \tab 2.3.2 }{\b\f20 cbf_free_handle}{\f20  \par \tab 2.3.3 }{\b\f20 cbf_read_file}{\f20  \par \tab 2.3.4 }{\b\f20 cbf_write_file}{\f20  \par \tab 2.3.5 }{\b\f20 cbf_new_datablock}{\f20  \par \tab 2.3.6 }{\b\f20 cbf_force_new_datablock}{\f20  \par \tab 2.3.7 }{\b\f20 cbf_new_category}{\f20  \par \tab 2.3.8 }{\b\f20 cbf_force_new_category}{\f20  \par \tab 2.3.9 }{\b\f20 cbf_new_column}{\f20  \par \tab 2.3.10 }{\b\f20 cbf_new_row}{\f20  \par \tab 2.3.11 }{\b\f20 cbf_insert_row}{\f20  \par \tab 2.3.12 }{\b\f20 cbf_delete_row}{\f20  \par \tab 2.3.13 }{\b\f20 cbf_set_datablockname}{\f20  \par \tab 2.3.14 }{\b\f20 cbf_reset_datablocks}{\f20  \par \tab 2.3.15 }{\b\f20 cbf_reset_datablock}{\f20  \par \tab 2.3.16 }{\b\f20 cbf_reset_category}{\f20  \par \tab 2.3.17 }{\b\f20 cbf_remove_datablock}{\f20  \par \tab 2.3.18 }{\b\f20 cbf_remove_category}{\f20  \par \tab 2.3.19 }{\b\f20 cbf_remove_column}{\f20  \par \tab 2.3.20 }{\b\f20 cbf_remove_row}{\f20  \par \tab 2.3.21 }{\b\f20 cbf_rewind_datablock}{\f20  \par \tab 2.3.22 }{\b\f20 cbf_rewind_category}{\f20  \par \tab 2.3.23 }{\b\f20 cbf_rewind_column}{\f20  \par \tab 2.3.24 }{\b\f20 cbf_rewind_row}{\f20  \par \tab 2.3.25 }{\b\f20 cbf_next_datablock}{\f20  \par \tab 2.3.26 }{\b\f20 cbf_next_category}{\f20  \par \tab 2.3.27 }{\b\f20 cbf_next_column}{\f20  \par \tab 2.3.28 }{\b\f20 cbf_next_row}{\f20  \par \tab 2.3.29 }{\b\f20 cbf_find_datablock}{\f20  \par \tab 2.3.30 }{\b\f20 cbf_find_category}{\f20  \par \tab 2.3.31 }{\b\f20 cbf_find_column}{\f20  \par \tab 2.3.32 }{\b\f20 cbf_find_row}{\f20  \par \tab 2.3.33 }{\b\f20 cbf_find_nextrow}{\f20  \par \tab 2.3.34 }{\b\f20 cbf_count_datablocks}{\f20  \par \tab 2.3.35 }{\b\f20 cbf_count_categories}{\f20  \par \tab 2.3.36 }{\b\f20 cbf_count_columns}{\f20  \par \tab 2.3.37 }{\b\f20 cbf_count_rows}{\f20  \par \tab 2.3.38 }{\b\f20 cbf_select_datablock}{\f20  \par \tab 2.3.39 }{\b\f20 cbf_select_category}{\f20  \par \tab 2.3.40 }{\b\f20 cbf_select_column}{\f20  \par \tab 2.3.41 }{\b\f20 cbf_select_row}{\f20  \par \tab 2.3.42 }{\b\f20 cbf_datablock_name}{\f20  \par \tab 2.3.43 }{\b\f20 cbf_category_name}{\f20  \par \tab 2.3.44 }{\b\f20 cbf_column_name}{\f20  \par \tab 2.3.45 }{\b\f20 cbf_row_number}{\f20  \par \tab 2.3.46 }{\b\f20 cbf_get_value}{\f20  \par \tab 2.3.47 }{\b\f20 cbf_set_value}{\f20  \par \tab 2.3.48 }{\b\f20 cbf_get_integervalue}{\f20  \par \tab 2.3.49 }{\b\f20 cbf_set_integervalue}{\f20  \par \tab 2.3.50 }{\b\f20 cbf_get_doublevalue}{\f20  \par \tab 2.3.51 }{\b\f20 cbf_set_doublevalue}{\f20  \par \tab 2.3.52 }{\b\f20 cbf_get_integerarrayparameters}{\f20  \par \tab 2.3.53 }{\b\f20 cbf_get_integerarray}{\f20  \par \tab 2.3.54 }{\b\f20 cbf_set_integerarray}{\f20  \par \tab 2.3.55 }{\b\f20 cbf_failnez}{\f20  \par \tab 2.3.56 }{\b\f20 cbf_onfailnez}{\f20  \par \par \tab 2.4 High-level function prototypes (new for version 0.7)\tab 64\par \par \tab 2.4.1 }{\b\f20 cbf_read_template}{\f20 \par \tab 2.4.2 }{\b\f20 cbf_get_diffrn_id}{\f20 \par \tab 2.4.3 }{\b\f20 cbf_set_diffrn_id}{\f20 \par \tab 2.4.4 }{\b\f20 cbf_get_crystal_id}{\f20 \par \tab 2.4.5 }{\b\f20 cbf_set_crystal_id}{\f20 \par \tab 2.4.6 }{\b\f20 cbf_get_wavelength}{\f20 \par \tab 2.4.7 }{\b\f20 cbf_set_wavelength}{\f20 \par \tab 2.4.8 }{\b\f20 cbf_get_polarization}{\f20 \par \tab 2.4.9 }{\b\f20 cbf_set_polarization}{\f20 \par \tab 2.4.10 }{\b\f20 cbf_get_divergence}{\f20 \par \tab 2.4.11 }{\b\f20 cbf_set_divergence}{\f20 \par \tab 2.4.12 }{\b\f20 cbf_count_elements}{\f20 \par \tab 2.4.13 }{\b\f20 cbf_get_element_id}{\f20 \par \tab 2.4.14 }{\b\f20 cbf_get_gain}{\f20 \par \tab 2.4.15 }{\b\f20 cbf_set_gain}{\f20 \par \tab 2.4.16 }{\b\f20 cbf_get_overload}{\f20 \par \tab 2.4.17 }{\b\f20 cbf_set_overload}{\f20 \par \tab 2.4.18 }{\b\f20 cbf_get_integration_time}{\f20 \par \tab 2.4.19 }{\b\f20 cbf_set_integration_time}{\f20 \par \tab 2.4.20 }{\b\f20 cbf_get_time}{\f20 \par \tab 2.4.21 }{\b\f20 cbf_set_time}{\f20 \par \tab 2.4.22 }{\b\f20 cbf_get_date}{\f20 \par \tab 2.4.23 }{\b\f20 cbf_set_date}{\f20 \par \tab 2.4.24 }{\b\f20 cbf_set_current_time}{\f20 \par \tab 2.4.25 }{\b\f20 cbf_get_image_size}{\f20 \par \tab 2.4.26 }{\b\f20 cbf_get_image}{\f20 \par \tab 2.4.27 }{\b\f20 cbf_set_image}{\f20 \par \tab 2.4.28 }{\b\f20 cbf_get_axis_setting}{\f20 \par \tab 2.4.29 }{\b\f20 cbf_set_axis_setting}{\f20 \par \tab 2.4.30 }{\b\f20 cbf_construct_goniometer}{\f20 \par \tab 2.4.31 }{\b\f20 cbf_free_goniometer}{\f20 \par \tab 2.4.32 }{\b\f20 cbf_get_rotation_axis}{\f20 \par \tab 2.4.33 }{\b\f20 cbf_get_rotation_range}{\f20 \par \tab 2.4.34 }{\b\f20 cbf_rotate_vector}{\f20 \par \tab 2.4.35 }{\b\f20 cbf_get_reciprocal}{\f20 \par \tab 2.4.36 }{\b\f20 cbf_construct_detector}{\f20 \par \tab 2.4.37 }{\b\f20 cbf_free_detector}{\f20 \par \tab 2.4.38 }{\b\f20 cbf_get_beam_center}{\f20 \par \tab 2.4.39 }{\b\f20 cbf_get_detector_distance}{\f20 \par \tab 2.4.40 }{\b\f20 cbf_get_detector_normal}{\f20 \par \tab 2.4.41 }{\b\f20 cbf_get_pixel_coordinates}{\f20 \par \tab 2.4.42 }{\b\f20 cbf_get_pixel_normal}{\f20 \par \tab 2.4.43 }{\b\f20 cbf_get_pixel_area}{\f20 \par \par \par 3. File format \tab 107\par \par \tab 3.1 General description \par \par \tab 3.2 Format of the binary sections \par \tab 3.2.1 Format of imgCIF binary sections \par \tab 3.2.2 Format of CBF binary sections \par \par \tab 3.3 Compression schemes \par \tab 3.3.1 Canonical-code compression \par \tab 3.3.2 CCP4-style compression \par \par 4. Installation \tab 113\par \par 5. Example programs \tab 115\par }\pard {\f20 \par }\pard {\f20 \par \sect }\sectd \sbkodd\pgnrestart\linemod0\linex0\cols1\endnhere \pard\plain \fs20 {\b\f20\fs28 1. Introduction}{\f20 \par }\pard {\f20 \par \par }\pard {\f20 CBFlib is a library of ANSI-C functions providing a simple mechanism for accessing Crystallographic Binary Files (CBF files) and Image-supporting CIF (imgCIF) files. The CBFlib API is loosely based on the CIFPARSE API for mmCIF files. Like CIFPARSE, CBFlib does not perform any semantic integrity checks and simply provides functions to create, read, modify and write CBF binary data files and imgCIF ASCII data files. \par }\pard {\f20 \par }\pard {\f20 \par \sect }\sectd \sbkodd\linemod0\linex0\cols1\endnhere \pard\plain \fs20 {\b\f20\fs28 2. Function descriptions}{\f20 \par }\pard {\f20 \par }{\b\f20 2.1 General description}{\f20 \par \par }\pard {\f20 Almost all of the CBFlib functions receive a value of type cbf_handle (a CBF handle) as the first argument.   Several of the high-level CBFlib functions dealing with geometry receive a value of type cbf_goniometer (a handle for a CBF goniometer object) or cbf_detector (a handle for a CBF detector object).\par }\pard {\f20 \par All functions return an integer equal to 0 for success or an error code for failure.\par \par \par }{\b\f20 2.1.1 CBF handles}{\f20 \par \par }\pard {\f20 CBFlib permits a program to use multiple CBF objects simultaneously. To identify the CBF object on which a function will operate, CBFlib uses a value of type cbf_handle. \par }\pard {\f20 \par Most functions in the library expect a value of type cbf_handle as the first argument. \par \par The function }{\b\f20 cbf_make_handle}{\f20  creates and initializes a new CBF handle. \par \par }\pard {\f20 The function }{\b\f20 cbf_free_handle}{\f20  destroys a handle and frees all memory associated with the corresponding CBF object.\par }\pard {\f20 \par \par }{\b\f20 2.1.2 CBF goniometer handles}{\f20 \par \par To represent the goniometer used to orient a sample, CBFlib uses a value of type cbf_goniometer. \par \par }\pard {\f20 A goniometer object is created and initialized from a CBF object using the function }{\b\f20 cbf_construct_goniometer}{\f20 . \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 The function }{\b\f20 cbf_free_goniometer}{\f20  destroys a goniometer handle and frees all memory associated with the corresponding object.\par }\pard {\f20 \par \par }{\b\f20 2.1.3 CBF detector handles}{\f20 \par \par To represent a detector surface mounted on a positioning system, CBFlib uses a value of type cbf_detector. \par \par }\pard {\f20 A goniometer object is created and initialized from a CBF object using the function }{\b\f20 cbf_construct_detector}{\f20 . \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 The function }{\b\f20 cbf_free_detector}{\f20  destroys a detector handle and frees all memory associated with the corresponding object.\par }\pard {\f20 \par \par }{\b\f20 2.1.4 Return values\par }{\f20 \par All of the CBFlib functions return 0 on success and an error code on failure. The error codes are: \par \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2970\clshdng0\cellx8200\pard \intbl {\f20 \~\~CBF_FORMAT\cell }\pard \intbl {\f20 The file format is invalid \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2970\clshdng0\cellx8200\pard \intbl {\f20 \~\~CBF_ALLOC\cell }\pard \intbl {\f20 Memory allocation failed \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_ARGUMENT\cell }\pard \intbl {\f20 Invalid function argument \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_ASCII\cell }\pard \intbl {\f20 The value is ASCII (not binary) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_BINARY\cell }\pard \intbl {\f20 The value is binary (not ASCII) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_BITCOUNT\cell }\pard \intbl {\f20 The expected number of bits does  not match the actual number written \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_ENDOFDATA\cell }\pard \intbl {\f20 The end of the data was reached before the end of the array \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_FILECLOSE\cell }\pard \intbl {\f20 File close error \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_FILEOPEN\cell }\pard \intbl {\f20 File open error \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_FILEREAD\cell }\pard \intbl {\f20 File read error \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_FILESEEK\cell }\pard \intbl {\f20 File seek error \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_FILETELL\cell }\pard \intbl {\f20 File tell error \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_FILEWRITE\cell }\pard \intbl {\f20 File write error \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_IDENTICAL\cell }\pard \intbl {\f20 A data block with the new name already exists \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_NOTFOUND\cell }\pard \intbl {\f20 The data block, category, column or row does not exist \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_OVERFLOW\cell }\pard \intbl {\f20 The number read cannot fit into the destination argument. The destination has been set to the nearest value. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~CBF_UNDEFINED\cell }\pard \intbl {\f20 The requested number is not defined (e.g. 0/0; new for version 0.7). \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2970\clshdng0\cellx8200\pard \intbl {\f20 \~\~CBF_NOTIMPLEMENTED\cell }\pard \intbl {\f20 The requested functionality is not yet implemented (New for version 0.7). \cell }\pard \intbl {\f20 \row }\pard {\f20 \par If more than one error has occurred, the error code is the logical OR of the individual error codes.\par \par 2.2 Reading and writing files containing binary sections\par \par 2.2.1 Reading binary sections\par \par \par }\pard {\f20 The current version of CBFlib only decompresses a binary section from disk when requested by the program. \par }\pard {\f20 \par }\pard {\f20 When a file containing one or more binary sections is read, CBFlib saves the file pointer and the position of the binary section within the file and then jumps past the binary section. When the program attempts to access the binary data, CBFlib sets the file position back to the start  of the binary section and then reads the data. \par }\pard {\f20 \par For this scheme to work: \par \par 1. The file must be a random-access file opened in binary mode (fopen ( ," rb")).\par }\pard {\f20 2. The program must not close the file. CBFlib will close the file using fclose ( ) when it is no longer needed. \par }\pard {\f20 \par }\pard {\f20 At present, this also means that a program cant read a file and then write back to the same file. This restriction will be eliminated in a future version. \par }\pard {\f20 \par When reading an imgCIF vs a CBF, the difference is detected automatically. \par \par \par }{\b\f20 2.2.2 Writing binary sections\par }{\f20 \par }\pard {\f20 When a program passes CBFlib a binary value, the data is compressed to a temporary file. If the CBF object is subsequently written to a file, the data is simply copied from the temporary file to the output file. \par }\pard {\f20 \par }\pard {\f20 The output file can be of any type. If the program indicates to CBFlib that the file is a random-access and readable, CBFlib will conserve disk space by closing the temporary file and using the output file as the location at which the binary value is stored. \par }\pard {\f20 \par For this option to work: \par \par 1. The file must be a random-access file opened in binary update mode (fopen ( , "w+b")).\par }\pard {\f20 2. The program must not close the file. CBFlib will close the file using fclose ( ) when it is no longer needed. \par }\pard {\f20 \par If this option is not used: \par \par 1. CBFlib will continue using the temporary file.\par 2. CBFlib will not close the file. This is the responsibility of the main program. \par \par }{\b\f20 2.2.3 Summary of reading and writing files containing binary sections\par }{\f20 \par 1. Open disk files to read using the mode "rb". \par }\pard {\f20 2. If possible, open disk files to write using the mode "w+b" and tell CBFlib that it can use the file as a buffer.\par }\pard {\f20 3. Do not close any files read by CBFlib or written by CBFlib with buffering turned on.\par }\pard {\f20 4. Do not attempt to read from a file, then write to the same file.\par }{\b\f20 \sect }\sectd \sbkodd\linemod0\linex0\cols1\endnhere \pard\plain \fs20 {\b\f20 2.3 Low-level function prototypes\par }{\f20 \par 2.3.1 }{\b\f20 cbf_make_handle}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_make_handle}{\f20  (cbf_handle *}{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_make_handle}{\f20  creates and initializes a new internal CBF object. All other CBFlib functions operating on this object receive the CBF handle as the first argument. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 Pointer to a CBF handle. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.2 }{\b\f20 cbf_free_handle}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.2 }{\b\f20 cbf_free_handle}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_free_handle}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_free_handle}{\f20  destroys the CBF object specified by the }{\i\f20 handle}{\f20  and frees all associated memory. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle to free. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.1 }{\b\f20 cbf_make_handle}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.3 }{\b\f20 cbf_read_file}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_read_file}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , FILE *}{\i\f20 file}{\f20 , int }{\i\f20 headers}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\b\f20 cbf_read_file}{\f20  reads the CBF or CIF file }{\i\f20 file}{\f20  into the CBF object specified by }{\i\f20 handle}{\f20 . \par }\pard {\f20 \par }\pard {\i\f20 headers}{\f20  controls the interprestation of binary section headers of imgCIF files. \par }\pard {\f20 \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 MSG_DIGEST:\cell }\pard \intbl {\f20 Instructs CBFlib to check that the digest of the binary section matches any header value. If the digests do not match, the call will return CBF_FORMAT. This evaluation and comparison is delayed (a "lazy" evaluation) to ensure maximal processing efficiency. If an immediately evaluation is required, see MSG_DIGESTNOW, below. \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 MSG_DIGESTNOW:\cell }\pard \intbl {\f20 Instructs CBFlib to check that the digest of the binary section matches any header value.  If the digests do not match, the call will return CBF_FORMAT. This evaluation and comparison is performed during initial parsing of the section to ensure timely error reporting at the expense of processing efficiency. If a more efficient delayed ("lazy") evaluation is required, see MSG_DIGESTNOW, below. \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 MSG_NODIGEST: \cell }\pard \intbl {\f20 Do not check the digest (default). \cell }\pard \intbl {\f20 \row }\pard {\f20 \par CBFlib defers reading binary sections as long as possible. In the current version of CBFlib, this means that: \par \par }\pard {\f20 1. The }{\i\f20 file}{\f20  must be a random-access file opened in binary mode (fopen ( , "rb")).\par }\pard {\f20 2. The program must not close the }{\i\f20 file}{\f20 . CBFlib will close the }{\i\f20 file}{\f20  using  fclose ( ) when it is no longer needed. \par }\pard {\f20 \par These restrictions may change in a future release. \par \par }{\b\f20 ARGUMENTS}{\f20\fs14 \par }\pard \tx2160 {\f20\fs14 \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 file}{\f20 \cell }\pard \intbl {\f20 Pointer to a file descriptor.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 headers}{\f20 \cell }\pard \intbl {\f20 Controls interprestation of binary section headers. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 2.3.4 }{\b\f20 cbf_write_file}{\f20 \par }\pard {\f20 \page \par }\pard {\f20 2.3.4 }{\b\f20 cbf_write_file}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard \fi-720\li720 {\f20 int }{\b\f20 cbf_write_file}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , FILE *}{\i\f20 file}{\f20 , int }{\i\f20 readable}{\f20 , int  }{\i\f20 ciforcbf}{\f20 , int }{\i\f20 headers}{\f20 , int }{\i\f20 encoding}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_write_file}{\f20  writes the CBF object specified by }{\i\f20 handle}{\f20  into the file }{\i\f20 file}{\f20 . \par }\pard {\f20 \par }\pard {\f20 Unlike }{\b\f20 cbf_read_file}{\f20 , the }{\i\f20 file}{\f20  does not have to be random-access. \par }\pard {\f20 \par }\pard {\f20 If the }{\i\f20 file}{\f20  is random-access and readable, }{\i\f20 readable}{\f20  can be set to non-0 to indicate to CBFlib that the }{\i\f20 file}{\f20  can be used as a buffer to conserve disk space. If the }{\i\f20 file}{\f20  is not random-access or not readable, }{\i\f20 readable}{\f20  must be 0. \par }\pard {\f20 \par }\pard {\f20 If }{\i\f20 readable}{\f20  is non-0, CBFlib will close the }{\i\f20 file}{\f20  when it is no longer required otherwise this is the responsibility of the program. \par }\pard {\f20 \par }\pard {\i\f20 ciforcbf}{\f20  selects the format in which the binary sections are written: \par }\pard {\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 CIF\cell }\pard \intbl {\f20 Write an imgCIF file. \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 CBF\cell }\pard \intbl {\f20 Write a CBF file (default). }{\i\f20 headers}{\f20  selects the type of header used in  CBF binary sections and selects whether message digests are generated. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }\pard {\f20 The value of }{\i\f20 headers}{\f20  can be a logical OR of any of: \par }\pard {\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 MIME_HEADERS\cell }\pard \intbl {\f20 Use MIME-type headers (default). \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 MIME_NOHEADERS\cell }\pard \intbl {\f20 Use a simple ASCII headers. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 MSG_DIGEST\cell }\pard \intbl {\f20 Generate message digests for binary data validation. \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 MSG_NODIGEST\cell }\pard \intbl {\f20 Do not generate message digests (default). \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }\pard {\i\f20 encoding}{\f20  selects the type of encoding used for binary sections and the type of line-termination in imgCIF files. The value can be a logical OR of any of: \par }\pard {\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 ENC_BASE64\cell }\pard \intbl {\f20 Use BASE64 encoding (default). \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 ENC_QP\cell }\pard \intbl {\f20 Use QUOTED-PRINTABLE encoding. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 ENC_BASE8\cell }\pard \intbl {\f20 Use BASE8 (octal) encoding. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 ENC_BASE10\cell }\pard \intbl {\f20 Use BASE10 (decimal) encoding. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 ENC_BASE16\cell }\pard \intbl {\f20 Use BASE16 (hexadecimal) encoding. \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 ENC_FORWARD\cell }\pard \intbl {\f20 For BASE8, BASE10 or BASE16 encoding, map bytes to words forward (1234) (default on little-endian machines). \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 ENC_BACKWARD\cell }\pard \intbl {\f20 Map bytes to words backward (4321) (default on big-endian machines). \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 ENC_CRTERM\cell }\pard \intbl {\f20 Terminate lines with CR. \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 ENC_LFTERM\cell }\pard \intbl {\f20 Terminate lines with LF (default). \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }\pard \keep\keepn {\b\f20 ARGUMENTS}{\f20 \par }\pard \fi-1080\li1080\keep\keepn {\f20 \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \keep\keepn\intbl {\i\f20 handle}{\f20 \cell }\pard \keep\keepn\intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \keep\keepn\intbl {\i\f20 file}{\f20 \cell }\pard \keep\keepn\intbl {\f20 Pointer to a file descriptor.\cell }\pard \intbl {\f20 \row }\pard \keep\keepn\intbl {\i\f20 readable}{\f20 \cell }\pard \keep\keepn\intbl {\f20 If non-0: this file is random-access and readable and can be used as a buffer. \cell }\pard \intbl {\f20 \row }\pard \keep\keepn\intbl {\i\f20 ciforcbf}{\f20 \cell }\pard \keep\keepn\intbl {\f20 Selects the format in which the binary sections are written (CIF/CBF). \cell }\pard \intbl {\f20 \row }\pard \keep\keepn\intbl {\i\f20 headers}{\f20 \cell }\pard \keep\keepn\intbl {\f20 Selects the type of header in CBF binary sections and message digest  generation. \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \keep\keepn\intbl {\i\f20 encoding}{\f20 \cell }\pard \keep\keepn\intbl {\f20 Selects the type of encoding used for binary sections and the type of line-termination in imgCIF files. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.3 }{\b\f20 cbf_read_file}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.5 }{\b\f20 cbf_new_datablock}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_new_datablock}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 datablockname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_new_datablock}{\f20  creates a new data block with name }{\i\f20 datablockname}{\f20  and makes it the current data block. \par }\pard {\f20 \par If a data block with this name already exists, the existing data block becomes the current data block. \par \par }\pard {\b\f20 ARGUMENTS\line }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 datablockname}{\f20 \cell }\pard \intbl {\f20 The name of the new data block. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.6 }{\b\f20 cbf_force_new_datablock}{\f20 \par 2.3.7 }{\b\f20 cbf_new_category}{\f20 \par 2.3.8 }{\b\f20 cbf_force_new_category}{\f20 \par 2.3.9 }{\b\f20 cbf_new_column}{\f20 \par 2.3.10 }{\b\f20 cbf_new_row}{\f20 \par 2.3.11 }{\b\f20 cbf_insert_row}{\f20 \par 2.3.12 }{\b\f20 cbf_set_datablockname}{\f20 \par 2.3.17 }{\b\f20 cbf_remove_datablock}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.6 }{\b\f20 cbf_force_new_data_block}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard \fi-720\li720 {\f20 int }{\b\f20 cbf_force_new_datablock}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 datablockname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_force_new_datablock}{\f20  creates a new data block with name }{\i\f20 datablockname}{\f20  and makes it the current data block. Duplicate data block names are allowed. \par }\pard {\f20 \par }\pard {\f20 Even if a data block with this name already exists, a new data block is created and becomes the current data block. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 datablockname}{\f20 \cell }\pard \intbl {\f20 The name of the new data block. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.5 }{\b\f20 cbf_new_datablock}{\f20 \par 2.3.7 }{\b\f20 cbf_new_category}{\f20 \par 2.3.8 }{\b\f20 cbf_force_new_category}{\f20 \par 2.3.9 }{\b\f20 cbf_new_column}{\f20 \par 2.3.10 }{\b\f20 cbf_new_row}{\f20 \par 2.3.11 }{\b\f20 cbf_insert_row}{\f20 \par 2.3.12 }{\b\f20 cbf_set_datablockname}{\f20 \par 2.3.17 }{\b\f20 cbf_remove_datablock}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.7 }{\b\f20 cbf_new_category}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_new_category}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 categoryname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_new_category}{\f20  creates a new category in the current data block with name }{\i\f20 categoryname}{\f20  and makes it the current category. \par }\pard {\f20 \par If a category with this name already exists, the existing category becomes the current category. \par \par }{\b\f20 ARGUMENTS}{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 categoryname}{\f20 \cell }\pard \intbl {\f20 The name of the new category. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.5 }{\b\f20 cbf_new_datablock}{\f20 \par 2.3.6 }{\b\f20 cbf_force_new_datablock}{\f20 \par 2.3.8 }{\b\f20 cbf_force_new_category}{\f20 \par 2.3.9 }{\b\f20 cbf_new_column}{\f20 \par 2.3.10 }{\b\f20 cbf_new_row}{\f20 \par 2.3.11 }{\b\f20 cbf_insert_row}{\f20 \par 2.3.18 }{\b\f20 cbf_remove_category}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.8 }{\b\f20 cbf_force_new_category}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_force_new_category}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 categoryname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_force_new_category}{\f20  creates a new category in the current data block with name }{\i\f20 categoryname}{\f20  and makes it the current category. Duplicate category names are allowed. \par }\pard {\f20 \par }\pard {\f20 Even if a category with this name already exists, a new category of the same name is created and becomes the current category. The allows for the creation of unlooped tag/value lists drawn from the same category. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 categoryname}{\f20 \cell }\pard \intbl {\f20 The name of the new category. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.5 }{\b\f20 cbf_new_datablock}{\f20 \par 2.3.6 }{\b\f20 cbf_force_new_datablock}{\f20 \par 2.3.7 }{\b\f20 cbf_new_category}{\f20 \par 2.3.9 }{\b\f20 cbf_new_column}{\f20 \par 2.3.10 }{\b\f20 cbf_new_row}{\f20 \par 2.3.11 }{\b\f20 cbf_insert_row}{\f20 \par 2.3.18 }{\b\f20 cbf_remove_category}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.9 }{\b\f20 cbf_new_column}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_new_column}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 columnname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_new_column}{\f20  creates a new column in the current category with name }{\i\f20 columnname}{\f20  and makes it the current column. \par }\pard {\f20 \par If a column with this name already exists, the existing column becomes the current category. \par \par }{\b\f20 ARGUMENTS}{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 columnname}{\f20 \cell }\pard \intbl {\f20 The name of the new column.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.5 }{\b\f20 cbf_new_datablock}{\f20 \par 2.3.6 }{\b\f20 cbf_force_new_datablock}{\f20 \par 2.3.7 }{\b\f20 cbf_new_category}{\f20 \par 2.3.8 }{\b\f20 cbf_force_new_category}{\f20 \par 2.3.10 }{\b\f20 cbf_new_row}{\f20 \par 2.3.11 }{\b\f20 cbf_insert_row}{\f20 \par 2.3.19 }{\b\f20 cbf_remove_column}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.10 }{\b\f20 cbf_new_row}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_new_row}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_new_row}{\f20  adds a new row to the current category and makes it the current row. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.5 }{\b\f20 cbf_new_datablock}{\f20 \par 2.3.6 }{\b\f20 cbf_force_new_datablock}{\f20 \par 2.3.7 }{\b\f20 cbf_new_category}{\f20 \par 2.3.8 }{\b\f20 cbf_force_new_category}{\f20 \par 2.3.9 }{\b\f20 cbf_new_column}{\f20 \par 2.3.11 }{\b\f20 cbf_insert_row}{\f20 \par 2.3.12 }{\b\f20 cbf_delete_row}{\f20 \par 2.3.20 }{\b\f20 cbf_remove_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.11 }{\b\f20 cbf_insert_row}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_insert_row}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 rownumber}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_insert_row}{\f20  adds a new row to the current category. The new row is inserted as row }{\i\f20 rownumber}{\f20  and existing rows starting from }{\i\f20 rownumber}{\f20  are moved up by 1. The new row becomes the current row. \par }\pard {\f20 \par }\pard {\f20 If the category has fewer than }{\i\f20 rownumber}{\f20  rows, the function returns CBF_NOTFOUND. \par }\pard {\f20 \par The row numbers start from 0. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 rownumber}{\f20 \cell }\pard \intbl {\f20 The row number of the new row.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.5 }{\b\f20 cbf_new_datablock}{\f20 \par 2.3.6 }{\b\f20 cbf_force_new_datablock}{\f20 \par 2.3.7 }{\b\f20 cbf_new_category}{\f20 \par 2.3.8 }{\b\f20 cbf_force_new_category}{\f20 \par 2.3.9 }{\b\f20 cbf_new_column}{\f20 \par 2.3.10 }{\b\f20 cbf_new_row}{\f20 \par 2.3.12 }{\b\f20 cbf_delete_row}{\f20 \par 2.3.20 }{\b\f20 cbf_remove_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.12 }{\b\f20 cbf_delete_row}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_delete_row}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 rownumber}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_delete_row}{\f20  deletes a row from the current category. Rows starting from }{\i\f20 rownumber}{\f20  +1 are moved down by 1. If the current row was higher than }{\i\f20 rownumber}{\f20 , or if the current row is the last row, it will also move down by 1. \par }\pard {\f20 \par The row numbers start from 0. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 rownumber}{\f20 \cell }\pard \intbl {\f20 The number of the row to delete.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.10 }{\b\f20 cbf_new_row}{\f20 \par 2.3.11 }{\b\f20 cbf_insert_row}{\f20 \par 2.3.17 }{\b\f20 cbf_remove_datablock}{\f20 \par 2.3.18 }{\b\f20 cbf_remove_category}{\f20 \par 2.3.19 }{\b\f20 cbf_remove_column}{\f20 \par 2.3.20 }{\b\f20 cbf_remove_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.13 }{\b\f20 cbf_set_datablockname}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_datablockname}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 datablockname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_datablockname}{\f20  changes the name of the current data block to }{\i\f20 datablockname}{\f20 . \par }\pard {\f20 \par }\pard {\f20 If a data block with this name already exists (comparison is case-insensitive), the function returns CBF_IDENTICAL. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 datablockname}{\f20 \cell }\pard \intbl {\f20 The new data block name.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.5 }{\b\f20 cbf_new_datablock}{\f20 \par 2.3.14 }{\b\f20 cbf_reset_datablocks}{\f20 \par 2.3.15 }{\b\f20 cbf_reset_datablock}{\f20 \par 2.3.17 }{\b\f20 cbf_remove_datablock}{\f20 \par 2.3.42 }{\b\f20 cbf_datablock_name}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.14 }{\b\f20 cbf_reset_datablocks}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_reset_datablocks}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_reset_datablocks}{\f20  deletes all categories from all data blocks. \par \par The current data block does not change. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.15 }{\b\f20 cbf_reset_datablock}{\f20 \par 2.3.18 }{\b\f20 cbf_remove_category}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.15 }{\b\f20 cbf_reset_datablock}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_reset_datablock}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_reset_datablock}{\f20  deletes all categories from the current data block. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.14 }{\b\f20 cbf_reset_datablocks}{\f20 \par 2.3.18 }{\b\f20 cbf_remove_category}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.16 }{\b\f20 cbf_reset_category}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_reset_category}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_reset_category}{\f20  deletes all columns and rows from current category. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.16 }{\b\f20 cbf_reset_category}{\f20 \par 2.3.19 }{\b\f20 cbf_remove_column}{\f20 \par 2.3.20 }{\b\f20 cbf_remove_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.17 }{\b\f20 cbf_remove_datablock}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_remove_datablock}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_remove_datablock}{\f20  deletes the current data block. \par \par The current data block becomes undefined. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.5 }{\b\f20 cbf_new_datablock}{\f20 \par 2.3.6 }{\b\f20 cbf_force_new_datablock}{\f20 \par 2.3.18 }{\b\f20 cbf_remove_category}{\f20 \par 2.3.19 }{\b\f20 cbf_remove_column}{\f20 \par 2.3.20 }{\b\f20 cbf_remove_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.18 }{\b\f20 cbf_remove_category}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_remove_category}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_remove_category}{\f20  deletes the current category. \par \par The current category becomes undefined. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.7 }{\b\f20 cbf_new_category}{\f20 \par 2.3.8 }{\b\f20 cbf_force_new_category}{\f20 \par 2.3.17 }{\b\f20 cbf_remove_datablock}{\f20 \par 2.3.19 }{\b\f20 cbf_remove_column}{\f20 \par 2.3.20 }{\b\f20 cbf_remove_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.19 }{\b\f20 cbf_remove_column}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_remove_column}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_remove_column}{\f20  deletes the current column. \par \par The current column becomes undefined. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\~\par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.9 }{\b\f20 cbf_new_column}{\f20 \par 2.3.17 }{\b\f20 cbf_remove_datablock}{\f20 \par 2.3.18 }{\b\f20 cbf_remove_category}{\f20 \par 2.3.20 }{\b\f20 cbf_remove_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.20 }{\b\f20 cbf_remove_row}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_remove_row}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_remove_row}{\f20  deletes the current row in the current category. \par \par If the current row was the last row, it will move down by 1, otherwise, it will remain the same. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.10 }{\b\f20 cbf_new_row}{\f20 \par 2.3.11 }{\b\f20 cbf_insert_row}{\f20 \par 2.3.17 }{\b\f20 cbf_remove_datablock}{\f20 \par 2.3.18 }{\b\f20 cbf_remove_category}{\f20 \par 2.3.19 }{\b\f20 cbf_remove_column}{\f20 \par 2.3.12 }{\b\f20 cbf_delete_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.21 }{\b\f20 cbf_rewind_datablock}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_rewind_datablock}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_rewind_datablock}{\f20  makes the first data block the current data block. \par \par If there are no data blocks, the function returns CBF_NOTFOUND. \par \par The current category becomes undefined. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.22 }{\b\f20 cbf_rewind_category}{\f20 \par 2.3.19 }{\b\f20 cbf_rewind_column}{\f20 \par 2.3.24 }{\b\f20 cbf_rewind_row}{\f20 \par 2.3.25 }{\b\f20 cbf_next_datablock}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.22 }{\b\f20 cbf_rewind_category}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_rewind_category}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_rewind_category}{\f20  makes the first category in the current data block the current category. \par \par If there are no categories, the function returns CBF_NOTFOUND. \par \par The current column and row become undefined. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.21 }{\b\f20 cbf_rewind_datablock}{\f20 \par 2.3.19 }{\b\f20 cbf_rewind_column}{\f20 \par 2.3.24 }{\b\f20 cbf_rewind_row}{\f20 \par 2.3.26 }{\b\f20 cbf_next_category}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.23 }{\b\f20 cbf_rewind_column}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_rewind_column}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_rewind_column}{\f20  makes the first column in the current category the current column. \par \par If there are no columns, the function returns CBF_NOTFOUND. \par \par The current row is not affected. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.21 }{\b\f20 cbf_rewind_datablock}{\f20 \par 2.3.22 }{\b\f20 cbf_rewind_category}{\f20 \par 2.3.24 }{\b\f20 cbf_rewind_row}{\f20 \par 2.3.27 }{\b\f20 cbf_next_column}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.24 }{\b\f20 cbf_rewind_row}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_rewind_row}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_rewind_row}{\f20  makes the first row in the current category the current row. \par \par If there are no rows, the function returns CBF_NOTFOUND. \par \par The current column is not affected. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.21 }{\b\f20 cbf_rewind_datablock}{\f20 \par 2.3.22 }{\b\f20 cbf_rewind_category}{\f20 \par 2.3.19 }{\b\f20 cbf_rewind_column}{\f20 \par 2.3.28 }{\b\f20 cbf_next_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.25 }{\b\f20 cbf_next_datablock}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_next_datablock}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_next_datablock}{\f20  makes the data block following the current data block the current data block. \par \par If there are no more data blocks, the function returns CBF_NOTFOUND. \par \par The current category becomes undefined. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.21 }{\b\f20 cbf_rewind_datablock}{\f20 \par 2.3.26 }{\b\f20 cbf_next_category}{\f20 \par 2.3.27 }{\b\f20 cbf_next_column}{\f20 \par 2.3.28 }{\b\f20 cbf_next_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.26 }{\b\f20 cbf_next_category}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_next_category}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_next_category}{\f20  makes the category following the current category in the current data block the current category. \par }\pard {\f20 \par If there are no more categories, the function returns CBF_NOTFOUND. \par \par The current column and row become undefined. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.22 }{\b\f20 cbf_rewind_category}{\f20 \par 2.3.25 }{\b\f20 cbf_next_datablock}{\f20 \par 2.3.27 }{\b\f20 cbf_next_column}{\f20 \par 2.3.27 }{\b\f20 cbf_next_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.27 }{\b\f20 cbf_next_column}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_next_column}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_next_column}{\f20  makes the column following the current column in the current category the current column. \par }\pard {\f20 \par If there are no more columns, the function returns CBF_NOTFOUND. \par \par The current row is not affected. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.19 }{\b\f20 cbf_rewind_column}{\f20 \par 2.3.25 }{\b\f20 cbf_next_datablock}{\f20 \par 2.3.26 }{\b\f20 cbf_next_category}{\f20 \par 2.3.28 }{\b\f20 cbf_next_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.28 }{\b\f20 cbf_next_row}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_next_row}{\f20  (cbf_handle }{\i\f20 handle}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_next_row}{\f20  makes the row following the current row in the current category the current row. \par \par If there are no more rows, the function returns CBF_NOTFOUND. \par \par The current column is not affected. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.24 }{\b\f20 cbf_rewind_row}{\f20 \par 2.3.25 }{\b\f20 cbf_next_datablock}{\f20 \par 2.3.26 }{\b\f20 cbf_next_category}{\f20 \par 2.3.27 }{\b\f20 cbf_next_column}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.29 }{\b\f20 cbf_find_datablock}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_find_datablock}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 datablockname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_find_datablock}{\f20  makes the data block with name }{\i\f20 datablockname}{\f20  the current data block. \par }\pard {\f20 \par The comparison is case-insensitive. \par \par If the data block does not exist, the function returns CBF_NOTFOUND. \par \par The current category becomes undefined. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 datablockname}{\f20 \cell }\pard \intbl {\f20 The name of the data block to find.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.21 }{\b\f20 cbf_rewind_datablock}{\f20 \par 2.3.25 }{\b\f20 cbf_next_datablock}{\f20 \par 2.3.30 }{\b\f20 cbf_find_category}{\f20 \par 2.3.31 }{\b\f20 cbf_find_column}{\f20 \par 2.3.32 }{\b\f20 cbf_find_row}{\f20 \par 2.3.42 }{\b\f20 cbf_datablock_name}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.30 }{\b\f20 cbf_find_category}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_find_category}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 categoryname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_find_category}{\f20  makes the category in the current data block with name \par }\pard {\i\f20 categoryname}{\f20  the current category. \par }\pard {\f20 \par The comparison is case-insensitive. \par \par If the category does not exist, the function returns CBF_NOTFOUND. \par \par The current column and row become undefined. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 categoryname}{\f20 \cell }\pard \intbl {\f20 The name of the category to find.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.22 }{\b\f20 cbf_rewind_category}{\f20 \par 2.3.26 }{\b\f20 cbf_next_category}{\f20 \par 2.3.29 }{\b\f20 cbf_find_datablock}{\f20 \par 2.3.31 }{\b\f20 cbf_find_column}{\f20 \par 2.3.32 }{\b\f20 cbf_find_row}{\f20 \par 2.3.43 }{\b\f20 cbf_category_name}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.31 }{\b\f20 cbf_find_column}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_find_column}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 columnname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_find_column}{\f20  makes the columns in the current category with name }{\i\f20 columnname}{\f20  the current column. \par }\pard {\f20 \par The comparison is case-insensitive. \par \par If the column does not exist, the function returns CBF_NOTFOUND. \par \par The current row is not affected. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 columnname}{\f20 \cell }\pard \intbl {\f20 The name of column to find.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.19 }{\b\f20 cbf_rewind_column}{\f20 \par 2.3.27 }{\b\f20 cbf_next_column}{\f20 \par 2.3.29 }{\b\f20 cbf_find_datablock}{\f20 \par 2.3.30 }{\b\f20 cbf_find_category}{\f20 \par 2.3.32 }{\b\f20 cbf_find_row}{\f20 \par 2.3.44 }{\b\f20 cbf_column_name}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.32 }{\b\f20 cbf_find_row}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_find_row}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 value}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_find_row}{\f20  makes the first row in the current column with value }{\i\f20 value}{\f20  the current row. \par }\pard {\f20 \par The comparison is case-sensitive. \par \par If a matching row does not exist, the function returns CBF_NOTFOUND. \par \par The current column is not affected. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 value}{\f20 \cell }\pard \intbl {\f20 The value of the row to find.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.24 }{\b\f20 cbf_rewind_row}{\f20 \par 2.3.28 }{\b\f20 cbf_next_row}{\f20 \par 2.3.29 }{\b\f20 cbf_find_datablock}{\f20 \par 2.3.30 }{\b\f20 cbf_find_category}{\f20 \par 2.3.31 }{\b\f20 cbf_find_column}{\f20 \par 2.3.33 }{\b\f20 cbf_find_nextrow}{\f20 \par 2.3.46 }{\b\f20 cbf_get_value}{\f20 \par \par \par \par }\pard {\f20 \page \par }\pard {\f20 2.3.33 }{\b\f20 cbf_find_nextrow}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_find_nextrow}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 value}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_find_nextrow}{\f20  makes the makes the next row in the current column with value }{\i\f20 value}{\f20  the current row. The search starts from the row following the last row found with }{\b\f20 cbf_find_row}{\f20  or }{\b\f20 cbf_find_nextrow}{\f20 , or from the current row if the current row was defined using any other function. \par }\pard {\f20 \par The comparison is case-sensitive. \par \par If no more matching rows exist, the function returns CBF_NOTFOUND. \par \par The current column is not affected. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 value}{\f20 \cell }\pard \intbl {\f20 the value to search for.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.24 }{\b\f20 cbf_rewind_row}{\f20 \par 2.3.28 }{\b\f20 cbf_next_row}{\f20 \par 2.3.29 }{\b\f20 cbf_find_datablock}{\f20 \par 2.3.30 }{\b\f20 cbf_find_category}{\f20 \par 2.3.31 }{\b\f20 cbf_find_column}{\f20 \par 2.3.32 }{\b\f20 cbf_find_row}{\f20 \par 2.3.46 }{\b\f20 cbf_get_value}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.34 }{\b\f20 cbf_count_datablocks}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_count_datablocks}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int *}{\i\f20 datablocks}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_count_datablocks}{\f20  puts the number of data blocks in *}{\i\f20 datablocks}{\f20  . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 datablocks}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination data block count.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.35 }{\b\f20 cbf_count_categories}{\f20 \par 2.3.36 }{\b\f20 cbf_count_columns}{\f20 \par 2.3.37 }{\b\f20 cbf_count_rows}{\f20 \par 2.3.38 }{\b\f20 cbf_select_datablock}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.35 }{\b\f20 cbf_count_categories}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_count_categories}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int *}{\i\f20 categories}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_count_categories}{\f20  puts the number of categories in the current data block in *}{\i\f20 categories}{\f20 . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\~}{\i\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 categories}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination category count.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.34 }{\b\f20 cbf_count_datablocks}{\f20 \par 2.3.36 }{\b\f20 cbf_count_columns}{\f20 \par 2.3.37 }{\b\f20 cbf_count_rows}{\f20 \par 2.3.39 }{\b\f20 cbf_select_category}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.36 }{\b\f20 cbf_count_columns}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_count_columns}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int *}{\i\f20 columns}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }{\b\f20 cbf_count_columns}{\f20  puts the number of columns in the current category in \par }\pard {\f20 *}{\i\f20 columns}{\f20 .\par }\pard {\f20  \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 columns}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination column count.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.34 }{\b\f20 cbf_count_datablocks}{\f20 \par 2.3.35 }{\b\f20 cbf_count_categories}{\f20 \par 2.3.37 }{\b\f20 cbf_count_rows}{\f20 \par 2.3.40 }{\b\f20 cbf_select_column}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.37 }{\b\f20 cbf_count_rows}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_count_rows}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int *}{\i\f20 rows}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_count_rows}{\f20  puts the number of rows in the current category in *}{\i\f20 rows}{\f20 . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 rows}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination row count.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.34 }{\b\f20 cbf_count_datablocks}{\f20 \par 2.3.35 }{\b\f20 cbf_count_categories}{\f20 \par 2.3.36 }{\b\f20 cbf_count_columns}{\f20 \par 2.3.41 }{\b\f20 cbf_select_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.38 }{\b\f20 cbf_select_datablock}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_select_datablock}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 datablock}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_select_datablock}{\f20  selects data block number }{\i\f20 datablock}{\f20  as the current data block. \par }\pard {\f20 \par The first data block is number 0. \par \par If the data block does not exist, the function returns CBF_NOTFOUND. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 datablock}{\f20 \cell }\pard \intbl {\f20 Number of the data block to select.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.34 }{\b\f20 cbf_count_datablocks}{\f20 \par 2.3.39 }{\b\f20 cbf_select_category}{\f20 \par 2.3.40 }{\b\f20 cbf_select_column}{\f20 \par 2.3.41 }{\b\f20 cbf_select_row}{\f20  \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.39 }{\b\f20 cbf_select_category}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_select_category}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 category}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_select_category}{\f20  selects category number }{\i\f20 category}{\f20  in the current data block as the current category. \par }\pard {\f20 \par The first category is number 0. \par \par The current column and row become undefined. \par \par If the category does not exist, the function returns CBF_NOTFOUND. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 category}{\f20 \cell }\pard \intbl {\f20 Number of the category to select.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.35 }{\b\f20 cbf_count_categories}{\f20 \par 2.3.38 }{\b\f20 cbf_select_datablock}{\f20 \par 2.3.40 }{\b\f20 cbf_select_column}{\f20 \par 2.3.41 }{\b\f20 cbf_select_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.40 }{\b\f20 cbf_select_column}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_select_column}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 column}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_select_column}{\f20  selects column number }{\i\f20 column}{\f20  in the current category as the current column. \par }\pard {\f20 \par The first column is number 0. \par \par The current row is not affected \par \par If the column does not exist, the function returns CBF_NOTFOUND. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 column}{\f20 \cell }\pard \intbl {\f20 Number of the column to select.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.36 }{\b\f20 cbf_count_columns}{\f20 \par 2.3.38 }{\b\f20 cbf_select_datablock}{\f20 \par 2.3.39 }{\b\f20 cbf_select_category}{\f20 \par 2.3.41 }{\b\f20 cbf_select_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.41 }{\b\f20 cbf_select_row}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_select_row}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 row}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_select_row}{\f20  selects row number }{\i\f20 row}{\f20  in the current category as the current row. \par }\pard {\f20 \par The first row is number 0. \par \par The current column is not affected \par \par If the row does not exist, the function returns CBF_NOTFOUND. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 row}{\f20 \cell }\pard \intbl {\f20 Number of the row to select.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.37 }{\b\f20 cbf_count_rows}{\f20 \par 2.3.38 }{\b\f20 cbf_select_datablock}{\f20 \par 2.3.39 }{\b\f20 cbf_select_category}{\f20 \par 2.3.40 }{\b\f20 cbf_select_column}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.42 }{\b\f20 cbf_datablock_name}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_datablock_name}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char **}{\i\f20 datablockname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_datablock_name}{\f20  sets *}{\i\f20 datablockname}{\f20  to point to the name of the current data block. \par }\pard {\f20 \par The data block name will be valid as long as the data block exists and has not been renamed. \par \par The name must not be modified by the program in any way. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 datablockname}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination data block name pointer.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.29 }{\b\f20 cbf_find_datablock}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.43 }{\b\f20 cbf_category_name}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_category_name}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char **}{\i\f20 categoryname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_category_name}{\f20  sets *}{\i\f20 categoryname}{\f20  to point to the name of the current category of the current data block. \par }\pard {\f20 \par The category name will be valid as long as the category exists. \par \par The name must not be modified by the program in any way. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 categoryname}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination category name pointer.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.30 }{\b\f20 cbf_find_category}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.44 }{\b\f20 cbf_column_name}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_column_name}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char **}{\i\f20 columnname}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_column_name}{\f20  sets *}{\i\f20 columnname}{\f20  to point to the name of the current column of the current category. \par }\pard {\f20 \par The column name will be valid as long as the column exists. \par \par The name must not be modified by the program in any way. \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 columnname}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination column name pointer.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.31 }{\b\f20 cbf_find_column}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.45 }{\b\f20 cbf_row_number}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_row_number}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int *}{\i\f20 row}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_row_number}{\f20  sets *}{\i\f20 row}{\f20  to the number of the current row of the current \par }\pard {\f20 category. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 row}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination row number.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.41 }{\b\f20 cbf_select_row}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.46 }{\b\f20 cbf_get_value}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_get_value}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char **}{\i\f20 value}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_value}{\f20  sets *}{\i\f20 value}{\f20  to point to the ASCII value of the item at the current column and row. \par }\pard {\f20 \par }\pard {\f20 If the }{\i\f20 value}{\f20  is not ASCII, the function returns CBF_BINARY. \par }\pard {\f20 \par }\pard {\f20 The }{\i\f20 value}{\f20  will be valid as long as the item exists and has not been set to a new value. \par }\pard {\f20 \par }\pard {\f20 The }{\i\f20 value}{\f20  must not be modified by the program in any way. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 value}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination value pointer.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.47 }{\b\f20 cbf_set_value}{\f20 \par 2.3.48 }{\b\f20 cbf_get_integervalue}{\f20 \par 2.3.50 }{\b\f20 cbf_get_doublevalue}{\f20 \par 2.3.52 }{\b\f20 cbf_get_integerarrayparameters}{\f20 \par 2.3.53 }{\b\f20 cbf_get_integerarray}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.47 }{\b\f20 cbf_set_value}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_value}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 value}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_value}{\f20  sets the item at the current column and row to the ASCII value }{\i\f20 value}{\f20 . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 value}{\f20 \cell }\pard \intbl {\f20 ASCII value.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.46 }{\b\f20 cbf_get_value}{\f20 \par 2.3.49 }{\b\f20 cbf_set_integervalue}{\f20 \par 2.3.51 }{\b\f20 cbf_set_doublevalue}{\f20 \par 2.3.54 }{\b\f20 cbf_set_integerarray}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.48 }{\b\f20 cbf_get_integervalue}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_get_integervalue}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , int *}{\i\f20 number}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_integervalue}{\f20  sets *}{\i\f20 number}{\f20  to the value of the ASCII item at the current column and row interpreted as a decimal integer. \par }\pard {\f20 \par If the value is not ASCII, the function returns CBF_BINARY. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 \~CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 number}{\f20 \cell }\pard \intbl {\f20 pointer to the number.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.46 }{\b\f20 cbf_get_value}{\f20 \par 2.3.49 }{\b\f20 cbf_set_integervalue}{\f20 \par 2.3.50 }{\b\f20 cbf_get_doublevalue}{\f20 \par 2.3.52 }{\b\f20 cbf_get_integerarrayparameters}{\f20 \par 2.3.53 }{\b\f20 cbf_get_integerarray}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.49 }{\b\f20 cbf_set_integervalue}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_integervalue}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , int }{\i\f20 number}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_integervalue}{\f20  sets the item at the current column and row to the integer value }{\i\f20 number}{\f20  written as a decimal ASCII string. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 number}{\f20 \cell }\pard \intbl {\f20 Integer value.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.46 }{\b\f20 cbf_get_value}{\f20 \par 2.3.47 }{\b\f20 cbf_set_value}{\f20 \par 2.3.48 }{\b\f20 cbf_get_integervalue}{\f20 \par 2.3.49 }{\b\f20 cbf_set_integervalue}{\f20 \par 2.3.51 }{\b\f20 cbf_set_doublevalue}{\f20 \par 2.3.54 }{\b\f20 cbf_set_integerarray}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.50 }{\b\f20 cbf_get_doublevalue}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_get_doublevalue}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , double *}{\i\f20 number}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_doublevalue}{\f20  sets *}{\i\f20 number}{\f20  to the value of the ASCII item at the current column and row interpreted as a decimal floating-point number. \par }\pard {\f20 \par If the value is not ASCII, the function returns CBF_BINARY. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 number}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination number.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.46 }{\b\f20 cbf_get_value}{\f20 \par 2.3.48 }{\b\f20 cbf_get_integervalue}{\f20 \par 2.3.51 }{\b\f20 cbf_set_doublevalue}{\f20 \par 2.3.52 }{\b\f20 cbf_get_integerarrayparameters}{\f20 \par 2.3.53 }{\b\f20 cbf_get_integerarray}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.51 }{\b\f20 cbf_set_doublevalue}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_doublevalue}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 format}{\f20 , double }{\i\f20 number}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_doublevalue}{\f20  sets the item at the current column and row to the floating-point value }{\i\f20 number}{\f20  written as an ASCII string with the format specified by }{\i\f20 format}{\f20  as appropriate for the printf function. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 format}{\f20 \cell }\pard \intbl {\f20 Format for the number.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 number}{\f20 \cell }\pard \intbl {\f20 Floating-point value.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.46 }{\b\f20 cbf_get_value}{\f20 \par 2.3.47 }{\b\f20 cbf_set_value}{\f20 \par 2.3.49 }{\b\f20 cbf_set_integervalue}{\f20 \par 2.3.50 }{\b\f20 cbf_get_doublevalue}{\f20 \par 2.3.54 }{\b\f20 cbf_set_integerarray}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.52 }{\b\f20 cbf_get_integerarrayparameters}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf.h"\par \par }\pard \fi-720\li720 {\f20 int }{\b\f20 cbf_get_integerarrayparameters}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int * }{\i\f20 compression}{\f20 , int *}{\i\f20 binary_id}{\f20 , size_t *}{\i\f20 elsize}{\f20 , int *}{\i\f20 elsigned}{\f20 , int *}{\i\f20 elunsigned}{\f20 , size_t *}{\i\f20 elements}{\f20 , int *}{\i\f20 minelement}{\f20 , int *}{\i\f20 maxelement)}{\f20 ; \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_integerarrayparameters}{\f20  sets *}{\i\f20 compression}{\f20 , *}{\i\f20 binary_id}{\f20 , *}{\i\f20 elsize}{\f20 , *}{\i\f20 elsigned}{\f20 , *}{\i\f20 elunsigned}{\f20 , *}{\i\f20 elements}{\f20 , *}{\i\f20 minelement}{\f20  and *}{\i\f20 maxelement}{\f20  to values read from the binary value of the item at the current column and row.   This provides all the arguments needed for a subsequent call to }{\b\f20 cbf_set_integerarray}{\f20 , if a copy of the arry is to be made into another CIF or CBF. \par }\pard {\f20 \par If the value is not binary, the function returns CBF_ASCII. \par \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 compression}{\f20 \cell }\pard \intbl {\f20 Compression method used.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elsize}{\f20 \cell }\pard \intbl {\f20 Size in bytes of each array element.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 binary_id}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination integer binary identifier.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elsigned}{\f20 \cell }\pard \intbl {\f20 Pointer to an integer. Set to 1 if the elements can be read as signed integers.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elunsigned}{\f20 \cell }\pard \intbl {\f20 Pointer to an integer. Set to 1 if the elements can be read as unsigned integers.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elements}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination number of elements.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 minelement}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination smallest element.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 maxelement}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination largest element.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.46 }{\b\f20 cbf_get_value}{\f20 \par 2.3.48 }{\b\f20 cbf_get_integervalue}{\f20 \par 2.3.50 }{\b\f20 cbf_get_doublevalue}{\f20 \par 2.3.53 }{\b\f20 cbf_get_integerarray}{\f20 \par 2.3.54 }{\b\f20 cbf_set_integerarray}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.53 }{\b\f20 cbf_get_integerarray}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 #include "cbf.h"\par \par }\pard \fi-720\li720 {\f20 int }{\b\f20 cbf_get_integerarray}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , int *}{\i\f20 binary_id}{\f20 , void *}{\i\f20 array}{\f20 ,  size_t }{\i\f20 elsize}{\f20 , int }{\i\f20 elsigned}{\f20 , size_t }{\i\f20 elements}{\f20 , size_t *}{\i\f20 elements_read}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\b\f20 cbf_get_integerarray}{\f20  reads the binary value of the item at the current column and row into an integer }{\i\f20 array}{\f20 . The array consists of elements }{\i\f20 elements}{\f20  of }{\i\f20 elsize}{\f20  bytes each, starting at }{\i\f20 array}{\f20 . The elements are signed if }{\i\f20 elsigned}{\f20  is non-0 and unsigned otherwise. *}{\i\f20 binary_id}{\f20  is set to the binary section identifier and *}{\i\f20 elements_read}{\f20  to the number of elements actually read. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 If any element in the binary data cant fit into the destination element, the destination is set the nearest possible value. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 If the value is not binary, the function returns CBF_ASCII. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 If the requested number of elements cant be read, the function will read as many as it can and then return CBF_ENDOFDATA. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 Currently, the destination }{\i\f20 array}{\f20  must consist of chars, shorts or ints (signed or unsigned). If }{\i\f20 elsize}{\f20  is not equal to sizeof (char), sizeof (short) or sizeof (int), the function returns CBF_ARGUMENT. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 An additional restriction in the current version of CBFlib is that values too large to fit in an int are not correctly decompressed. As an example, if the machine with 32-bit ints is reading an array containing a value outside the range 0 .. 2^32-1 (unsigned) or -2^31 .. 2^31-1 (signed), the array will not be correctly decompressed. This restriction will be removed in a future release. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20\fs14 \par }\pard {\f20\fs14 \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 binary_id}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination integer binary identifier.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 array}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination array.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elsize}{\f20 \cell }\pard \intbl {\f20 Size in bytes of each destination array element.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elsigned}{\f20 \cell }\pard \intbl {\f20 Set to non-0 if the destination array elements are signed.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elements}{\f20 \cell }\pard \intbl {\f20 The number of elements to read.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 elements_read}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination number of elements actually read.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 Returns an error code on failure or 0 for success.\par }{\b\f20 \par SEE ALSO}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 2.3.46 }{\b\f20 cbf_get_value}{\f20 \par 2.3.48 }{\b\f20 cbf_get_integervalue}{\f20 \par 2.3.50 }{\b\f20 cbf_get_doublevalue}{\f20 \par 2.3.52 }{\b\f20 cbf_get_integerarrayparameters}{\f20 \par 2.3.54 }{\b\f20 cbf_set_integerarray}{\f20 \par }\pard {\b\f20 \page \par }\pard {\f20 2.3.54 }{\b\f20 cbf_set_integerarray}{\f20 \par \par }{\b\f20 PROTOTYPE}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 #include "cbf.h"\par \par }\pard \fi-720\li720 {\f20 int }{\b\f20 cbf_set_integerarray}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 compression}{\f20 , int }{\i\f20 binary_id}{\f20 , void *}{\i\f20 array}{\f20 , size_t }{\i\f20 elsize}{\f20 , int }{\i\f20 elsigned}{\f20 , size_t }{\i\f20 elements}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\b\f20 cbf_set_integerarray}{\f20  sets the binary value of the item at the current column and row to an integer }{\i\f20 array}{\f20 . The }{\i\f20 array}{\f20  consists of elements}{\i\f20 elements}{\f20  of }{\i\f20 elsize}{\f20  bytes each, starting at }{\i\f20 array}{\f20 . The elements are signed if }{\i\f20 elsigned}{\f20  is non-0 and unsigned otherwise. }{\i\f20 binary_id}{\f20  is the binary section identifier. \par }\pard {\f20 \par }\pard {\f20 The }{\i\f20 array}{\f20  will be compressed using the compression scheme specifed by}{\i\f20 compression}{\f20 .  Currently, the available schemes are: \par }\pard {\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 CBF_CANONICAL\cell }\pard \intbl {\f20 Canonical-code compression (section 3.3.1)\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 CBF_PACKED\cell }\pard \intbl {\f20 CCP4-style packing (section 3.3.2) \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 CBF_NONE\cell }\pard \intbl {\f20 No compression. }{\b\f20 NOTE:}{\f20  This scheme is by far the slowest of the three and uses much more disk space. It is intended for routine use with small arrays only. With large arrays (like images) it should be used only for debugging. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }\pard {\f20 The values compressed are limited to 64 bits. If any element in the }{\i\f20 array}{\f20  is larger than 64 bits, the value compressed is the nearest 64-bit value. \par }\pard {\f20 \par }\pard {\f20 Currently, the source }{\i\f20 array}{\f20  must consist of chars, shorts or ints (signed or unsigned). If }{\i\f20 elsize}{\f20  is not equal to sizeof (char), sizeof (short) or sizeof (int), the function returns CBF_ARGUMENT. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\b\f20\fs14 \par }\pard {\f20\fs14 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 compression}{\f20 \cell }\pard \intbl {\f20 Compression method to use.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 binary_id}{\f20 \cell }\pard \intbl {\f20 Integer binary identifier.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 array}{\f20 \cell }\pard \intbl {\f20 Pointer to the source array.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elsize}{\f20 \cell }\pard \intbl {\f20 Size in bytes of each source array element.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elsigned}{\f20 \cell }\pard \intbl {\f20 Set to non-0 if the source array elements are signed.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 elements}{\f20 \cell }\pard \intbl {\f20 The number of elements in the }{\i\f20 array}{\f20 . \cell }\pard \intbl {\f20 \row }\pard {\b\f20 \par RETURN VALUE}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 Returns an error code on failure or 0 for success. \par \par }{\b\f20 SEE ALSO}{\f20  }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 2.3.47 }{\b\f20 cbf_set_value}{\f20 \par 2.3.49 }{\b\f20 cbf_set_integervalue}{\f20 \par 2.3.51 }{\b\f20 cbf_set_doublevalue}{\f20 \par 2.3.52 }{\b\f20 cbf_get_integerarrayparameters}{\f20 \par 2.3.53 }{\b\f20 cbf_get_integerarray}{\f20 \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.55 }{\b\f20 cbf_failnez}{\f20 \par \par \par }{\b\f20 DEFINITION}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 #define }{\b\f20 cbf_failnez}{\f20 (}{\i\f20 f}{\f20 ) \{int err; err = (}{\i\f20 f}{\f20 ); if (err) return err; \} \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_failnez}{\f20  is a macro used for error propagation throughout CBFlib.  }{\b\f20 cbf_failnez}{\f20  executes the function }{\i\f20 f}{\f20  and saves the returned error value.   If the error value is non-0, }{\b\f20 cbf_failnez}{\f20  executes a return with the error value as argument. If CBFDEBUG is defined, then a report of the error is also printed to the standard error stream, stderr, in the form \par }\pard {\f20 \par }\pard {\f20 CBFlib error }{\i\f20 f}{\f20  in "symbol" \par }\pard {\f20 \par }\pard {\f20 where }{\i\f20 f}{\f20  is the decimal value of the error and symbol is the symbolic form. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 f}{\f20 \cell }\pard \intbl {\f20 Integer error value.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 SEE ALSO}{\f20  \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 2.3.56 }{\b\f20 cbf_onfailnez}{\f20 \par \par \par \par \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.3.56 }{\b\f20 cbf_onfailnez}{\f20 \par \par \par }{\b\f20 DEFINITION}{\f20  \par \par #include "cbf.h"\par \par }\pard {\f20 #define }{\b\f20 cbf_onfailnez}{\f20 (}{\i\f20 f}{\f20 ,}{\i\f20 c}{\f20 ) \{int err; err = (}{\i\f20 f}{\f20 ); if (err) \{\{}{\i\f20 c}{\f20 ; \}return err; \}\} \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_onfailnez}{\f20  is a macro used for error propagation throughout CBFlib.   }{\b\f20 cbf_onfailnez}{\f20  executes the function }{\i\f20 f}{\f20  and saves the returned error value. If the error value is non-0, }{\b\f20 cbf_failnez}{\f20  executes first the statement }{\i\f20 c}{\f20  and then a return with the error value as argument. If CBFDEBUG is defined, then a report of the error is also printed to the standard error stream, stderr, in the form \par }\pard {\f20 \par }\pard {\f20 CBFlib error }{\i\f20 f}{\f20  in "symbol" \par }\pard {\f20 \par }\pard {\f20 where }{\i\f20 f}{\f20  is the decimal value of the error and symbol is the symbolic form. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 f}{\f20 \cell }\pard \intbl {\f20 integer function to execute.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 c}{\f20 \cell }\pard \intbl {\f20 statement to execute on failure.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 SEE ALSO}{\f20  \par \par 2.3.55 }{\b\f20 cbf_failnez}{\f20 \par \par \par \par \par }\pard {\b\f20 \page \par }\pard {\b\f20 2.4 High-level function prototypes\par }{\f20 \par 2.4.1 }{\b\f20 cbf_read_template}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_read_template}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , FILE *}{\i\f20 file}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_read_template }{\f20 reads the CBF or CIF file }{\i\f20 file}{\f20  into the CBF object specified by }{\i\f20 handle}{\f20  and selects the first datablock as the current datablock. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 Pointer to a CBF handle. \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 file}{\f20 \cell }\pard \intbl {\f20 Pointer to a file descriptor. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }\pard {\f20 \page \par }\pard {\f20 2.4.2 }{\b\f20 cbf_get_diffrn_id}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_get_diffrn_id}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char **}{\i\f20 diffrn_id}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_diffrn_id }{\f20 sets *}{\i\f20 diffrn_id}{\f20  to point to the ASCII value of the \ldblquote diffrn.id\rdblquote  entry. \par }\pard {\f20 \par }\pard {\f20 The }{\i\f20 diffrn_id}{\f20  will be valid as long as the item exists and has not been set to a new value. \par }\pard {\f20 \par }\pard {\f20 The }{\i\f20 diffrn_id}{\f20  must not be modified by the program in any way. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 diffrn_id}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination value pointer.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.3 }{\b\f20 cbf_set_diffrn_id}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_diffrn_id}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 diffrn_id}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_diffrn_id }{\f20 sets the \ldblquote diffrn.id\rdblquote  entry of the current datablock to the ASCII value }{\i\f20 diffrn_id}{\f20 . \par }\pard {\f20 \par }\pard {\f20 This function also changes corresponding \ldblquote diffrn_id\rdblquote  entries in the \ldblquote diffrn_source\rdblquote , \ldblquote diffrn_radiation\rdblquote , \ldblquote diffrn_detector\rdblquote  and \ldblquote diffrn_measurement\rdblquote  categories.\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 diffrn_id}{\f20 \cell }\pard \intbl {\f20 ASCII value.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par \par }\pard {\f20 \page \par }\pard {\f20 2.4.4 }{\b\f20 cbf_get_crystal_id}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_get_crystal_id}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char **}{\i\f20 crystal_id}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_crystal_id }{\f20 sets *}{\i\f20 crystal_id}{\f20  to point to the ASCII value of the \ldblquote diffrn.crystal_id\rdblquote  entry. \par }\pard {\f20 \par }\pard {\f20 If the }{\i\f20 value}{\f20  is not ASCII, the function returns CBF_BINARY. \par }\pard {\f20 \par }\pard {\f20 The }{\i\f20 value}{\f20  will be valid as long as the item exists and has not been set to a new value. \par }\pard {\f20 \par }\pard {\f20 The }{\i\f20 value}{\f20  must not be modified by the program in any way. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 crystal_id}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination value pointer.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.5 }{\b\f20 cbf_set_crystal_id}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_crystal_id}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , const char *}{\i\f20 crystal_id}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_crystal_id }{\f20 sets the \ldblquote diffrn.crystal_id\rdblquote  entry to the ASCII value }{\i\f20 crystal_id}{\f20 . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 crystal_id}{\f20 \cell }\pard \intbl {\f20 ASCII value.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.6 }{\b\f20 cbf_get_wavelength}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_get_wavelength}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , double *}{\i\f20 wavelength}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_wavelength }{\f20 sets *}{\i\f20 wavelength}{\f20  to the current wavelength in \'81. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 wavelength}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.7 }{\b\f20 cbf_set_wavelength}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_wavelength}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , double }{\i\f20 wavelength}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_wavelength }{\f20 sets the current wavelength in \'81 to }{\i\f20 wavelength}{\f20 . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 wavelength}{\f20 \cell }\pard \intbl {\f20 Wavelength in \'81.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.8 }{\b\f20 cbf_get_polarization}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard int {\b cbf_get_polarization} (cbf_handle {\i handle}, double *{\i polarizn_source_ratio}, \par \pard \fi720 double *{\i polarizn_source_norm});\par \pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_polarization }{\f20 sets *}{\i\f20 polarizn_source_ratio }{\f20 and *}{\i\f20 polarizn_source_norm}{\f20  to the corresponding source polarization parameters. \par }\pard {\f20 \par Either destination pointer may be NULL.\par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20  polarizn_source_ratio}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination polarizn_source_ratio.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20  polarizn_source_norm}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination polarizn_source_norm.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.9 }{\b\f20 cbf_set_polarization}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_polarization}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , double }{\i\f20 polarizn_source_ratio}{\f20 ,\par }\pard \fi720 {\f20 double }{\i\f20 polarizn_source_norm}{\f20 );\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_polarization }{\f20 sets the source polarization to the values specified by }{\i\f20 polarizn_source_ratio}{\f20  and }{\i\f20 polarizn_source_norm}{\f20 . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20  polarizn_source_ratio}{\f20 \cell }\pard \intbl {\f20 New value of polarizn_source_ratio.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20  polarizn_source_norm}{\f20 \cell }\pard \intbl {\f20 New value of polarizn_source_norm.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.10 }{\b\f20 cbf_get_divergence}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_get_divergence}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , double *}{\i\f20 div_x_source}{\f20 , double *}{\i\f20 div_y_source}{\f20 ,\par \tab double *}{\i\f20 div_x_y_source}{\f20 );\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_divergence }{\f20 sets *}{\i\f20 div_x_source}{\f20 ,}{\i\f20  *div_y_source}{\f20  and *}{\i\f20 div_x_y_source}{\f20  to the corresponding source divergence parameters. \par }\pard {\f20 \par Any of the destination pointers may be NULL.\par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 div_x_source}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination div_x_source.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 div_y_source}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination div_y_source.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 div_x_y_source}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination div_x_y_source.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.11 }{\b\f20 cbf_ set_divergence}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_divergence}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , double }{\i\f20 div_x_source}{\f20 , double }{\i\f20 div_y_source}{\f20 ,\par \tab double }{\i\f20 div_x_y_source}{\f20 );\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_divergence }{\f20 sets the source divergence parameters to the values specified by d}{\i\f20 iv_x_source}{\f20 ,}{\i\f20  div_y_source}{\f20  and }{\i\f20 div_x_y_source}{\f20 . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 div_x_source}{\f20 \cell }\pard \intbl {\f20 New value of div_x_source.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 div_y_source}{\f20 \cell }\pard \intbl {\f20 New value of div_y_source.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 div_x_y_source}{\f20 \cell }\pard \intbl {\f20 New value of div_x_y_source.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.12 }{\b\f20 cbf_count_elements}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_count_elements}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int *}{\i\f20 elements}{\f20 );\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_count_elements }{\f20 sets *}{\i\f20 elements}{\f20   to the number of detector elements. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 elements}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination count.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \tab \par }\pard {\f20 2.4.13 }{\b\f20 cbf_get_element_id}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_element_id}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 element_number}{\f20 , const char **}{\i\f20 element_id}{\f20 );\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_element_id }{\f20 sets *}{\i\f20 element_id}{\f20  to point to the ASCII value of the }{\i\f20 element_number}{\f20 \rquote th \ldblquote }{\f2010 diffrn_data_frame.detector_}{\f20 element_id\rdblquote  entry, counting from 0. \par }\pard {\f20 \par If the detector element does not exist, the function returns CBF_NOTFOUND. \par \par }\pard {\f20 The }{\i\f20 element_id}{\f20  will be valid as long as the item exists and has not been set to a new value. \par }\pard {\f20 \par }\pard {\f20 The }{\i\f20 element_id}{\f20  must not be modified by the program in any way. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 element_number}{\f20 \cell }\pard \intbl {\f20 The number of the detector element counting from 0 by order of appearance in the \ldblquote diffrn_data_frame\rdblquote  category.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 element_id}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.14 }{\b\f20 cbf_get_gain}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_get_gain}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 element_number}{\f20 , double *}{\i\f20 gain}{\f20 , double *}{\i\f20 gain_esd}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_gain }{\f20 sets *}{\i\f20 gain}{\f20  and *}{\i\f20 gain_esd}{\f20  to the corresponding gain parameters for element number }{\i\f20 element_number}{\f20 . \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 Either of the destination pointers may be NULL.\par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 element_number}{\f20 \cell }\pard \intbl {\f20 The number of the detector element counting from 0 by order of appearance in the \ldblquote diffrn_data_frame\rdblquote  category.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 gain}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination gain.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 gain_esd}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination gain_esd.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.15 }{\b\f20 cbf_ set_gain}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_gain}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 element_number}{\f20 , double }{\i\f20 gain}{\f20 , double }{\i\f20 gain_esd}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 cbf_set_gain }{\f20 sets the gain of element number }{\i\f20 element_number}{\f20  to the values specified by }{\i\f20 gain}{\f20  and }{\i\f20  gain_esd}{\f20 . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 element_number}{\f20 \cell }\pard \intbl {\f20 The number of the detector element counting from 0 by order of appearance in the \ldblquote diffrn_data_frame\rdblquote  category.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 gain}{\f20 \cell }\pard \intbl {\f20 New gain value.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 gain_esd}{\f20 \cell }\pard \intbl {\f20 New gain_esd value.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.16 }{\b\f20 cbf_get_overload}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_get_overload}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 element_number}{\f20 , double *}{\i\f20 overload}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_overload }{\f20 sets *}{\i\f20 overload}{\f20  to the overload value for element number }{\i\f20 element_number}{\f20 . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 element_number}{\f20 \cell }\pard \intbl {\f20 The number of the detector element counting from 0 by order of appearance in the \ldblquote diffrn_data_frame\rdblquote  category.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 overload}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination overload.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.17 }{\b\f20 cbf_ set_overload}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_overload}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int }{\i\f20 element_number}{\f20 , double }{\i\f20 overload}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 cbf_set_overload }{\f20 sets the overload value of element number }{\i\f20 element_number}{\f20  to }{\i\f20 overload}{\f20 . \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 element_number}{\f20 \cell }\pard \intbl {\f20 The number of the detector element counting from 0 by order of appearance in the \ldblquote diffrn_data_frame\rdblquote  category.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 overload}{\f20 \cell }\pard \intbl {\f20 New overload value.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.18 }{\b\f20 cbf_get_integration_time}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_integration_time}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , double *}{\i\f20 time}{\f20 );\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_integration_time }{\f20 sets *}{\i\f20 time}{\f20  to the integration time in seconds.   The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 time}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination time.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.19 }{\b\f20 cbf_set_integration_time}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_integration_time}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , double }{\i\f20 time}{\f20 );\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 cbf_set_integration_time }{\f20 sets the integration time in seconds to the value specified by }{\i\f20 time}{\f20 .  The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 time}{\f20 \cell }\pard \intbl {\f20 Integration time in seconds.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.20 }{\b\f20 cbf_get_timestamp}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_timestamp}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , double *}{\i\f20 time}{\f20 , int *}{\i\f20 timezone}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_timestamp }{\f20 sets *}{\i\f20 time}{\f20  to the collection timestamp in seconds since January 1 1970.  *}{\i\f20 timezone}{\f20  is set to timezone difference from UTC in minutes.  The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 Either of the destination pointers may be NULL.\par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 time}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination collection timestamp.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 timezone}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination timezone difference.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.21 }{\b\f20 cbf_set_timestamp}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_timestamp}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , double }{\i\f20 time, }{\f20 int}{\i\f20  timezone,\par }\pard \fi720 {\f20 double}{\i\f20  precision}{\f20 );\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 cbf_set_timestamp }{\f20 sets the collection timestamp in seconds since January 1 1970 to the value specified by }{\i\f20 time}{\f20 .  The timezone difference from UTC in minutes is set to }{\i\f20 timezone}{\f20 .   If no timezone is desired, }{\i\f20 timezone}{\f20  should be CBF_NOTIMEZONE.  The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }\pard {\f20 The precision of the new timestamp is specified by the value }{\i\f20 precision}{\f20  in seconds.  If }{\i\f20 precision}{\f20  is 0, the saved timestamp is assumed accurate to 1 second}{\i\f20 .}{\f20  \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 time}{\f20 \cell }\pard \intbl {\f20 Timestamp in seconds since January 1 1970.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 timezone}{\f20 \cell }\pard \intbl {\f20 Timezone difference from UTC in minutes or CBF_NOTIMEZONE.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 precision}{\f20 \cell }\pard \intbl {\f20 Timestamp precision in seconds.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.22 }{\b\f20 cbf_get_datestamp}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_datestamp}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , int *}{\i\f20 year}{\f20 , int *}{\i\f20 month}{\f20 , int *}{\i\f20 day}{\f20 ,\par }\pard \fi720 {\f20 int *}{\i\f20 hour}{\f20 , int *}{\i\f20 minute}{\f20 , double *}{\i\f20 second}{\f20 , int *}{\i\f20 timezone}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_datestamp }{\f20 sets *}{\i\f20 year}{\f20 , *}{\i\f20 month}{\f20 , *}{\i\f20 day}{\f20 , *}{\i\f20 hour}{\f20 , *}{\i\f20 minute}{\f20  and *}{\i\f20 second}{\f20  to the corresponding values of the collection timestamp.  *}{\i\f20 timezone}{\f20  is set to timezone difference from UTC in minutes.  The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 Any of the destination pointers may be NULL.\par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 year}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination timestamp year.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 month}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination timestamp month (1-12).\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 day}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination timestamp day (1-31).\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 hour}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination timestamp hour (0-23).\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 minute}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination timestamp minute (0-59).\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 second}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination timestamp second (0-60.0).\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 timezone}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination timezone difference from UTC in minutes.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.23 }{\b\f20 cbf_set_datestamp}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_datestamp}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , int }{\i\f20 year}{\f20 , int }{\i\f20 month}{\f20 , int }{\i\f20 day}{\f20 , int }{\i\f20 hour}{\f20 ,\par }\pard \fi720 {\f20 int }{\i\f20 minute}{\f20 , double }{\i\f20 second}{\f20 , int }{\i\f20 timezone}{\f20 , double }{\i\f20 precision}{\f20 );\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 cbf_set_datestamp }{\f20 sets the collection timestamp in seconds since January 1 1970 to the value specified by }{\i\f20 time}{\f20 .  The timezone difference from UTC in minutes is set to }{\i\f20 timezone}{\f20 .   If no timezone is desired, }{\i\f20 timezone}{\f20  should be CBF_NOTIMEZONE.  The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }\pard {\f20 The precision of the new timestamp is specified by the value }{\i\f20 precision}{\f20  in seconds.  If }{\i\f20 precision}{\f20  is 0, the saved timestamp is assumed accurate to 1 second}{\i\f20 .}{\f20  \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 time}{\f20 \cell }\pard \intbl {\f20 Timestamp in seconds since January 1 1970.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 timezone}{\f20 \cell }\pard \intbl {\f20 Timezone difference from UTC in minutes or CBF_NOTIMEZONE.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 precision}{\f20 \cell }\pard \intbl {\f20 Timestamp precision in seconds.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.24 }{\b\f20 cbf_set_current_timestamp}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_set_current_timestamp}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , int }{\i\f20 timezone}{\f20 )\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 DESCRIPTION}{\f20  \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 cbf_set_current_timestamp }{\f20 sets the collection timestamp to the current time.  The timezone difference from UTC in minutes is set to }{\i\f20 timezone}{\f20 .   If no timezone is desired, }{\i\f20 timezone}{\f20  should be CBF_NOTIMEZONE.  If no timezone is used, the timestamp will be UTC.  The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }\pard {\f20 The new timestamp will have a precision of 1 second}{\i\f20 .}{\f20  \par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 timezone}{\f20 \cell }\pard \intbl {\f20 Timezone difference from UTC in minutes or CBF_NOTIMEZONE.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.25 }{\b\f20 cbf_get_image_size}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_image_size}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , unsigned int }{\i\f20 element_number}{\f20 ,\par }\pard \fi720 {\f20 size_t *}{\i\f20 ndim1}{\f20 , size_t *}{\i\f20 ndim2}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_image_size }{\f20 sets *}{\i\f20 ndim1}{\f20  and  *}{\i\f20 ndim2}{\f20  to the slow and fast dimensions of the image array for element number }{\i\f20 element_number}{\f20 .   If the array is 1-dimensional, *}{\i\f20 ndim1}{\f20  will be set to the array size and *}{\i\f20 ndim2}{\f20  will be set to 1. \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 Either of the destination pointers may be NULL.\par \par }\pard {\f20 The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 element_number}{\f20 \cell }\pard \intbl {\f20 The number of the detector element counting from 0 by order of appearance in the \ldblquote diffrn_data_frame\rdblquote  category.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 ndim1}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination slow dimension.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 ndim2}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination fast dimension.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.26 }{\b\f20 cbf_get_image}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_image}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , unsigned int }{\i\f20 element_number}{\f20 , void *}{\i\f20 array}{\f20 ,\par }\pard \fi720 {\f20 size_t }{\i\f20 elsize}{\f20 , int }{\i\f20 elsign}{\f20 , size_t }{\i\f20 ndim1}{\f20 , size_t }{\i\f20 ndim2}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_image}{\f20  reads the image array for element number }{\i\f20 element_number}{\f20  into an array.  The array consists of }{\i\f20 ndim1}{\f20 \'d7 }{\i\f20 ndim2}{\f20  elements of }{\i\f20 elsize}{\f20  bytes each, starting at }{\i\f20 array}{\f20 .  The elements are signed if }{\i\f20 elsigned}{\f20  is non-0 and unsigned otherwise. \par }\pard {\f20 \par }\pard {\f20 If the array is 1-dimensional, }{\i\f20 ndim1}{\f20  should be the array size and }{\i\f20 ndim2}{\f20  should be set to 1.}{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 If any element in the binary data can\rquote t fit into the destination element, the destination is set the nearest possible value. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 If the value is not binary, the function returns CBF_ASCII. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 If the requested number of elements can\rquote t be read, the function will read as many as it can and then return CBF_ENDOFDATA. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 Currently, the destination }{\i\f20 array}{\f20  must consist of chars, shorts or ints (signed or unsigned). If }{\i\f20 elsize}{\f20  is not equal to sizeof (char), sizeof (short) or sizeof (int), the function returns CBF_ARGUMENT. }{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 An additional restriction in the current version of CBFlib is that values too large to fit in an int are not correctly decompressed. As an example, if the machine with 32-bit ints is reading an array containing a value outside the range 0 .. 232-1 (unsigned) or -231 .. 231-1 (signed), the array will not be correctly decompressed. This restriction will be removed in a future release. \par }\pard {\f20 \par }\pard {\f20 The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 element_number}{\f20 \cell }\pard \intbl {\f20 The number of the detector element counting from 0 by order of appearance in the \ldblquote diffrn_data_frame\rdblquote  category.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 array}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination array.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elsize}{\f20 \cell }\pard \intbl {\f20 Size in bytes of each destination array element.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elsigned}{\f20 \cell }\pard \intbl {\f20 Set to non-0 if the destination array elements are signed.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 ndim1}{\f20 \cell }\pard \intbl {\f20 Slow array dimension.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 ndim2}{\f20 \cell }\pard \intbl {\f20 Fast array dimension.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.27 }{\b\f20 cbf_set_image}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_set_image}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , unsigned int }{\i\f20 element_number}{\f20 ,\par }\pard \fi720 {\f20 unsigned int }{\i\f20 compression}{\f20 , void *}{\i\f20 array}{\f20 , size_t }{\i\f20 elsize}{\f20 , int }{\i\f20 elsign}{\f20 , size_t }{\i\f20 ndim1}{\f20 , size_t }{\i\f20 ndim2}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_image}{\f20  writes the image array for element number }{\i\f20 element_number}{\f20 .  The array consists of }{\i\f20 ndim1}{\f20 \'d7 }{\i\f20 ndim2}{\f20  elements of }{\i\f20 elsize}{\f20  bytes each, starting at }{\i\f20 array}{\f20 .  The elements are signed if }{\i\f20 elsigned}{\f20  is non-0 and unsigned otherwise. \par }\pard {\f20 \par }\pard {\f20 If the array is 1-dimensional, }{\i\f20 ndim1}{\f20  should be the array size and }{\i\f20 ndim2}{\f20  should be set to 1.}{\f20\fs14 \par }\pard {\f20\fs14 \par }\pard {\f20 The }{\i\f20 array}{\f20  will be compressed using the compression scheme specifed by }{\i\f20 compression}{\f20 .  Currently, the available schemes are: \par }\pard {\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 CBF_CANONICAL\cell }\pard \intbl {\f20 Canonical-code compression (section 3.3.1)\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 CBF_PACKED\cell }\pard \intbl {\f20 CCP4-style packing (section 3.3.2) \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 CBF_NONE\cell }\pard \intbl {\f20 No compression. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }\pard {\f20 The values compressed are limited to 64 bits. If any element in the }{\i\f20 array}{\f20  is larger than 64 bits, the value compressed is the nearest 64-bit value. \par }\pard {\f20 \par }\pard {\f20 Currently, the source }{\i\f20 array}{\f20  must consist of chars, shorts or ints (signed or unsigned). If }{\i\f20 elsize}{\f20  is not equal to sizeof (char), sizeof (short) or sizeof (int), the function returns CBF_ARGUMENT. \par }\pard {\f20 \par }\pard {\f20 The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 element_number}{\f20 \cell }\pard \intbl {\f20 The number of the detector element counting from 0 by order of appearance in the \ldblquote diffrn_data_frame\rdblquote  category.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 compression}{\f20 \cell }\pard \intbl {\f20 Compression type.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 array}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination array.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elsize}{\f20 \cell }\pard \intbl {\f20 Size in bytes of each destination array element.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 elsigned}{\f20 \cell }\pard \intbl {\f20 Set to non-0 if the destination array elements are signed.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 ndim1}{\f20 \cell }\pard \intbl {\f20 Slow array dimension.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 ndim2}{\f20 \cell }\pard \intbl {\f20 Fast array dimension.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.28 }{\b\f20 cbf_get_axis_setting}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_axis_setting}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , const char *}{\i\f20 axis_id}{\f20 , double *}{\i\f20 start}{\f20 ,\par }\pard \fi720 {\f20 double *}{\i\f20 increment}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_axis_setting }{\f20 sets *}{\i\f20 start}{\f20  and *}{\i\f20 increment}{\f20  to the corresponding values of the axis }{\i\f20 axis_id}{\f20 .\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 Either of the destination pointers may be NULL.\par \par }\pard {\f20 The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 axis_id}{\f20 \cell }\pard \intbl {\f20 Axis id.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 start}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination start value.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 increment}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination increment value.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.29 }{\b\f20 cbf_set_axis_setting}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_set_axis_setting}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , const char *}{\i\f20 axis_id}{\f20 , double }{\i\f20 start}{\f20 ,\par }\pard \fi720 {\f20 double }{\i\f20 increment}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_set_axis_setting }{\f20 sets the starting and increment values of the axis }{\i\f20 axis_id}{\f20  to }{\i\f20 start}{\f20  and }{\i\f20 increment}{\f20 .\par }\pard {\f20 \par }\pard {\f20 The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 axis_id}{\f20 \cell }\pard \intbl {\f20 Axis id.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 start}{\f20 \cell }\pard \intbl {\f20 Start value.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 increment}{\f20 \cell }\pard \intbl {\f20 Increment value.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.30 }{\b\f20 cbf_construct_goniometer}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_construct_goniometer}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , cbf_goniometer *}{\i\f20 goniometer}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_construct_goniometer }{\f20 constructs a goniometer object using the description in the CBF object }{\i\f20 handle }{\f20 and initialises the goniometer handle *}{\i\f20 goniometer}{\f20 .\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 goniometer}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination goniometer handle.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.31 }{\b\f20 cbf_free_goniometer}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_free_goniometer}{\f20  (cbf_goniometer }{\i\f20 goniometer}{\f20 ); \par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_free_goniometer}{\f20  destroys the goniometer object specified by }{\i\f20 goniometer}{\f20  and frees all associated memory. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 goniometer}{\f20 \cell }\pard \intbl {\f20 Goniometer handle to free. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\b\f20 \page }{\f20 \par }\pard {\f20 2.4.32 }{\b\f20 cbf_get_rotation_axis}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_rotation_axis}{\f20  (cbf_goniometer }{\i\f20 goniometer}{\f20 , unsigned int }{\i\f20 reserved}{\f20 , double *}{\i\f20 vector1}{\f20 ,\par }\pard \fi720 {\f20 double *}{\i\f20 vector2}{\f20 , double }{\i\f20 vector3}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_rotation_axis }{\f20 sets *}{\i\f20 vector1}{\f20 , *}{\i\f20 vector2}{\f20 , and *}{\i\f20 vector3}{\f20  to the 3 components of the goniometer rotation axis used for the exposure.\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 Any of the destination pointers may be NULL.\par \par }\pard {\f20 The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 goniometer}{\f20 \cell }\pard \intbl {\f20 Goniometer handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 vector1}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 x}{\f20  component of the rotation axis.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 vector2}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Pointer to the destination }{\i\f20 y}{\f20  component of the rotation axis.\cell }\pard\plain \intbl \fs20 {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 vector3}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 z}{\f20  component of the rotation axis.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.33 }{\b\f20 cbf_get_rotation_range}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_rotation_range}{\f20  (cbf_goniometer }{\i\f20 goniometer}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , double *}{\i\f20 start}{\f20 ,\par }\pard \fi720 {\f20 double *}{\i\f20 increment}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_rotation_range }{\f20 sets *}{\i\f20 start}{\f20  and *}{\i\f20 increment}{\f20  to the corresponding values of the goniometer rotation axis used for the exposure.\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 Either of the destination pointers may be NULL.\par \par }\pard {\f20 The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 goniometer}{\f20 \cell }\pard \intbl {\f20 Goniometer handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 start}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination start value.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 increment}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Pointer to the destination increment value.\cell }\pard\plain \intbl \fs20 {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.34 }{\b\f20 cbf_rotate_vector}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_rotate_vector}{\f20  (cbf_goniometer }{\i\f20 goniometer}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , double }{\i\f20 ratio}{\f20 , double }{\i\f20 initial1}{\f20 ,\par }\pard \fi720 {\f20 double }{\i\f20 initial2}{\f20 , double }{\i\f20 initial3}{\f20 , double *}{\i\f20 final1}{\f20 , double *}{\i\f20 final2}{\f20 , double *}{\i\f20 final3}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_rotate_vector }{\f20 sets *}{\i\f20 final1}{\f20 , *}{\i\f20 final2}{\f20 , and *}{\i\f20 final3}{\f20  to the 3 components of the of the vector (}{\i\f20 initial1}{\f20 , }{\i\f20 initial2}{\f20 , }{\i\f20 initial3}{\f20 ) after reorientation by applying the goniometer rotations.  The value }{\i\f20 ratio}{\f20  specifies the goniometer setting and varies from 0.0 at the beginning of the exposure to 1.0 at the end, irrespective of the actual rotation range.\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 Any of the destination pointers may be NULL.\par \par }\pard {\f20 The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 goniometer}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Goniometer handle.\cell }\pard\plain \intbl \fs20 {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 ratio}{\f20 \cell }\pard \intbl {\f20 Goniometer setting.  0 = beginning of exposure, 1 = end.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 initial1}{\f20 \cell }\pard \intbl {\i\f20 x}{\f20  component of the initial vector.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 initial2}{\f20 \cell }\pard \intbl {\i\f20 y}{\f20  component of the initial vector.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 initial3}{\f20 \cell }\pard \intbl {\i\f20 z}{\f20  component of the initial vector.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 vector1}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 x}{\f20  component of the final vector.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 vector2}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Pointer to the destination }{\i\f20 y}{\f20  component of the final vector.\cell }\pard\plain \intbl \fs20 {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 vector3}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 z}{\f20  component of the final vector.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.35 }{\b\f20 cbf_get_reciprocal}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_reciprocal}{\f20  (cbf_goniometer }{\i\f20 goniometer}{\f20 , unsigned int  }{\i\f20 reserved}{\f20 , double }{\i\f20 ratio}{\f20 ,\par }\pard \fi720 {\f20 double }{\i\f20 wavelength}{\f20 , double }{\i\f20 real1}{\f20 , double }{\i\f20 real2}{\f20 , double }{\i\f20 real3}{\f20 , double *}{\i\f20 reciprocal1}{\f20 ,\par double *}{\i\f20 reciprocal2}{\f20 , double *}{\i\f20 reciprocal3}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 cbf_get_reciprocal }{\f20 sets *}{\i\f20 reciprocal1}{\f20 , *}{\i\f20  reciprocal2}{\f20 , and *}{\i\f20  reciprocal3}{\f20  to the 3 components of the of the reciprocal-space vector corresponding to the real-space vector (}{\i\f20 real1}{\f20 , }{\i\f20 real2}{\f20 , }{\i\f20 real3}{\f20 ).  The reciprocal-space vector is oriented to correspond to the goniometer setting with all axes at 0.  The value }{\i\f20 wavelength}{\f20  is the wavlength in \'81 and the value }{\i\f20 ratio}{\f20  specifies the current goniometer setting and varies from 0.0 at the beginning of the exposure to 1.0 at the end, irrespective of the actual rotation range.\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 Any of the destination pointers may be NULL.\par \par }\pard {\f20 The parameter }{\i\f20 reserved}{\f20  is presently unused and should be set to 0.\par }\pard {\f20 \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 goniometer}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Goniometer handle.\cell }\pard\plain \intbl \fs20 {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reserved}{\f20 \cell }\pard \intbl {\f20 Unused.  Any value other than 0 is invalid.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 ratio}{\f20 \cell }\pard \intbl {\f20 Goniometer setting.  0 = beginning of exposure, 1 = end.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 wavelength}{\f20 \cell }\pard \intbl {\f20 Wavelength in \'81.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 real1}{\f20 \cell }\pard \intbl {\i\f20 x}{\f20  component of the real-space vector.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 real2}{\f20 \cell }\pard \intbl {\i\f20 y}{\f20  component of the real-space vector.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 real3}{\f20 \cell }\pard \intbl {\i\f20 z}{\f20  component of the real-space vector.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 reciprocal1}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 x}{\f20  component of the reciprocal-space vector.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 reciprocal2}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Pointer to the destination }{\i\f20 y}{\f20  component of the reciprocal-space vector.\cell }\pard\plain \intbl \fs20 {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 reciprocal3}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 z}{\f20  component of the reciprocal-space vector.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.36 c}{\b\f20 bf_construct_detector}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int c}{\b\f20 bf_construct_detector}{\f20  (cbf_handle }{\i\f20 handle}{\f20 , cbf_detector *}{\i\f20 detector}{\f20 , unsigned int }{\i\f20 element_number}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\f20 c}{\b\f20 bf_construct_detector }{\f20 constructs a detector object for detector element number }{\i\f20 element_number}{\f20  using the description in the CBF object }{\i\f20 handle }{\f20 and initialises the detector handle *}{\i\f20 detector}{\f20 .\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 handle}{\f20 \cell }\pard \intbl {\f20 CBF handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 detector}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination detector handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 element_number}{\f20 \cell }\pard \intbl {\f20 The number of the detector element counting from 0 by order of appearance in the \ldblquote diffrn_data_frame\rdblquote  category.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.37 }{\b\f20 cbf_free_detector}{\f20  \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par \par }\pard {\f20 int }{\b\f20 cbf_free_detector}{\f20  (cbf_detector }{\i\f20 detector}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_free_detector}{\f20  destroys the detector object specified by }{\i\f20 detector}{\f20  and frees all associated memory. \par }\pard {\f20 \par }{\b\f20 ARGUMENTS\par }{\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 detector}{\f20 \cell }\pard \intbl {\f20 Detector handle to free. \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.38 }{\b\f20 cbf_get_beam_center}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_beam_center}{\f20  (cbf_detector }{\i\f20 detector}{\f20 , double *}{\i\f20 index1}{\f20 , double *}{\i\f20 index2}{\f20 , double *}{\i\f20 center1}{\f20 ,\par }\pard \fi720 {\f20 double *}{\i\f20 center2}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_beam_center }{\f20 sets *}{\i\f20 center1}{\f20  and *}{\i\f20 center2}{\f20  to the displacements in mm along the detector axes from pixel (0, 0) to the point at which the beam intersects the detector and *}{\i\f20 index1}{\f20  and *}{\i\f20 index2}{\f20  to the corresponding indices.\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 Any of the destination pointers may be NULL.\par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 detector}{\f20 \cell }\pard \intbl {\f20 Detector handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 index1}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination slow index.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 index2}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Pointer to the destination fast index.\cell }\pard\plain \intbl \fs20 {\f20 \row }\pard \intbl {\i\f20 center1}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination displacement along the slow axis.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 center2}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination displacement along the fast axis.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.39 }{\b\f20 cbf_get_detector_distance}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_detector_distance}{\f20  (cbf_detector }{\i\f20 detector}{\f20 , double *}{\i\f20 distance}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard {\b\f20 cbf_get_detector_distance }{\f20 sets *}{\i\f20 distance}{\f20  to the nearest distance from the sample position to the detector plane.\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 detector}{\f20 \cell }\pard \intbl {\f20 Detector handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 distance}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination distance.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page  \par }\pard {\f20 2.4.40 }{\b\f20 cbf_get_detector_normal}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_detector_normal}{\f20  (cbf_detector }{\i\f20 detector}{\f20 , double *}{\i\f20 normal1}{\f20 , double *}{\i\f20 normal2}{\f20 , \par }\pard \fi720 {\f20 double *}{\i\f20 normal3}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard\plain \s243 \fs20 {\b\f20 cbf_get_detector_normal }{\f20 sets *}{\i\f20 normal1}{\f20 , *}{\i\f20 normal2}{\f20 , and *}{\i\f20 normal3}{\f20  to the 3 components of the of the normal vector to the detector plane.  The vector is normalized.\par }\pard\plain \fs20 {\f20 \par Any of the destination pointers may be NULL.\par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 detector}{\f20 \cell }\pard \intbl {\f20 Detector handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 normal1}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 x}{\f20  component of the normal vector.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 normal2}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Pointer to the destination }{\i\f20 y}{\f20  component of the normal vector.\cell }\pard\plain \intbl \fs20 {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 normal3}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 z}{\f20  component of the normal vector.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.41 }{\b\f20 cbf_get_pixel_coordinates}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_pixel_coordinates}{\f20  (cbf_detector }{\i\f20 detector}{\f20 , double }{\i\f20 index1}{\f20 , double }{\i\f20 index2}{\f20 , double *}{\i\f20 coordinate1}{\f20 ,\par \tab double *}{\i\f20 coordinate2}{\f20 , double *}{\i\f20 coordinate3}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard\plain \s243 \fs20 {\b\f20 cbf_get_pixel_coordinates }{\f20 sets *}{\i\f20 coordinate1}{\f20 , *}{\i\f20 coordinate2}{\f20 , and *}{\i\f20 coordinate3}{\f20  to the vector position of pixel (}{\i\f20 index1}{\f20 , }{\i\f20 index2}{\f20 ) on the detector surface.  If index1 and }{\i\f20 index2}{\f20  are integers then the coordinates correspond to the center of a pixel. \par }\pard\plain \fs20 {\f20 \par Any of the destination pointers may be NULL.\par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 detector}{\f20 \cell }\pard \intbl {\f20 Detector handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 index1}{\f20 \cell }\pard \intbl {\f20 Slow index.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 index2}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Fast index.\cell }\pard\plain \intbl \fs20 {\f20 \row }\pard \intbl {\i\f20 coordinate1}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 x}{\f20  component.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 coordinate2}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Pointer to the destination }{\i\f20 y}{\f20  component.\cell }\pard\plain \intbl \fs20 {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 coordinate3}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 z}{\f20  component.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.42 }{\b\f20 cbf_get_pixel_normal}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_pixel_normal}{\f20  (cbf_detector }{\i\f20 detector}{\f20 , double }{\i\f20 index1}{\f20 , double }{\i\f20 index2}{\f20 ,  double *}{\i\f20 normal1}{\f20 ,\par }\pard \fi720 {\f20 double *}{\i\f20 normal2}{\f20 , double *}{\i\f20 normal3}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard\plain \s243 \fs20 {\b\f20 cbf_get_detector_normal }{\f20 sets *}{\i\f20 normal1}{\f20 , *}{\i\f20 normal2}{\f20 , and *}{\i\f20 normal3}{\f20  to the 3 components of the of the normal vector to the pixel at (}{\i\f20 index1}{\f20 , }{\i\f20 index2}{\f20 ).  The vector is normalized.\par }\pard\plain \fs20 {\f20 \par Any of the destination pointers may be NULL.\par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 detector}{\f20 \cell }\pard \intbl {\f20 Detector handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 index1}{\f20 \cell }\pard \intbl {\f20 Slow index.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 index2}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Fast index.\cell }\pard\plain \intbl \fs20 {\f20 \row }\pard \intbl {\i\f20 normal1}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 x}{\f20  component of the normal vector.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 normal2}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Pointer to the destination }{\i\f20 y}{\f20  component of the normal vector.\cell }\pard\plain \intbl \fs20 {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 normal3}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination }{\i\f20 z}{\f20  component of the normal vector.\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par Returns an error code on failure or 0 for success. \par }\pard {\f20 \page \par }\pard {\f20 2.4.43 }{\b\f20 cbf_get_pixel_area}{\f20 \par \par \par }{\b\f20 PROTOTYPE}{\f20  \par \par #include "cbf_simple.h"\par }\pard\plain \s243 \fs20 {\f20 \par }\pard\plain \fs20 {\f20 int }{\b\f20 cbf_get_pixel_area}{\f20  (cbf_detector }{\i\f20 detector}{\f20 , double }{\i\f20 index1}{\f20 , double }{\i\f20 index2}{\f20 , double *}{\i\f20 area}{\f20 ,\par }\pard \fi720 {\f20 double *}{\i\f20 projected_area}{\f20 );\par }\pard {\f20 \par }{\b\f20 DESCRIPTION}{\f20  \par \par }\pard\plain \s243 \fs20 {\b\f20 cbf_get_pixel_area }{\f20 sets *}{\i\f20 area}{\f20  to the area of the pixel at (}{\i\f20 index1}{\f20 , }{\i\f20 index2}{\f20 ) on the detector surface and *}{\i\f20 projected_area}{\f20  to the apparent area of the pixel as viewed from the sample position. \par }\pard\plain \fs20 {\f20 \par Either of the destination pointers may be NULL.\par \par }{\b\f20 ARGUMENTS}{\f20 \par \~\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 detector}{\f20 \cell }\pard \intbl {\f20 Detector handle.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 index1}{\f20 \cell }\pard \intbl {\f20 Slow index.\cell }\pard \intbl {\f20 \row }\pard \intbl {\i\f20 index2}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Fast index.\cell }\pard\plain \intbl \fs20 {\f20 \row }\pard \intbl {\i\f20 area}{\f20 \cell }\pard \intbl {\f20 Pointer to the destination area in mm2.\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\i\f20 projected_area}{\f20 \cell }\pard\plain \s243\intbl \fs20 {\f20 Pointer to the destination apparent area in mm2.\cell }\pard\plain \intbl \fs20 {\f20 \row }\pard {\f20 \par }{\b\f20 RETURN VALUE}{\f20  \par \par }\pard {\f20 Returns an error code on failure or 0 for success. \par }{\b\f20\fs28 \sect }\sectd \sbkodd\linemod0\linex0\cols1\endnhere \pard\plain \fs20 {\b\f20\fs28 3. File format}{\f20 \par }\pard {\f20 \par }{\b\f20 3.1 General description}{\f20 \par \par }\pard {\f20 With the exception of the binary sections, a CBF file is an mmCIF-format ASCII file, so a CBF file with no binary sections is a CIF file. An imgCIF file has any binary sections encoded as CIF-format ASCII strings and is a CIF file whether or not it contains binary sections. In most cases, CBFlib can also be used to access normal CIF files as well as CBF and imgCIF files. \par }\pard {\f20 \par \par }{\b\f20 3.2 Format of the binary sections}{\f20 \par \par }\pard {\f20 Before getting to the binary data itself, there are some preliminaries to allow a smooth transition from the conventions of CIF to those of raw or encoded streams of "octets" (8-bit bytes). The binary data is given as the essential part of a specially formatted semicolon-delimited CIF multi-line text string. This text string is the value associated with the tag "_array_data.data". \par }\pard {\f20 \par The specific format of the binary sections differs between an imgCIF and a CBF file. \par \par \par }{\b\f20 3.2.1 Format of imgCIF binary sections}{\f20 \par \par }\pard {\f20 Each binary section is encoded as a ;-delimited string. Within the text string, the conventions developed for transmitting email messages including binary attachments are followed. There is secondary ASCII header information, formatted as Multipurpose Internet Mail Extensions (MIME) headers (see RFCs 2045-49 by Freed, et. al). The boundary marker for the beginning of all this is the special string \par }\pard {\f20 \par --CIF-BINARY-FORMAT-SECTION--\par \par }\pard {\f20 at the beginning of a line. The initial "--" says that this is a MIME  boundary. We cannot put "###" in front of it and conform to MIME  conventions. Immediately after the boundary marker are MIME headers,  describing some useful information we will need to process the binary section. MIME headers can appear in different orders, and can be very confusing (look at the raw contents of a email message with attachments), but there is only one header which is has to be understood to process an imgCIF: "Content-Transfer-Encoding". If the value given on this header is "BINARY", this is a CBF and the data will be presented as raw binary, containing a count (in the header described in 3.2.2 Format of CBF binary sections) so we'll know when to start looking for more information. \par }\pard {\f20 \par }\pard {\f20 If the value given for "Content-Tranfer-Encoding" is one of the real encodings: "BASE64", "QUOTED-PRINTABLE", "X-BASE8", "X-BASE10" or "X-BASE16", the file is an imgCIF, and we'll need some other the other headers to process the encoded binary data properly. It is a good practice to give headers in all cases. The meanings of various encodings is given in the CBF extensions dictionary, cif_img_1.1.3.dic. \par }\pard {\f20 \par The "Content-Type" header tells us what sort of data we have (currently \par }\pard {\f20 always "application/octet-stream" for a miscellaneous stream of binary data) and, optionally, the conversions that were applied to the original data. In this case we have compressed the data with the "CBF-PACKED" algorithm. \par }\pard {\f20 \par }\pard {\f20 The "X-Binary-ID" header should contain the same value as was given for "_array_data.}{\i\f20 binary_id}{\f20 ". \par }\pard {\f20 \par }\pard {\f20 The "X-Binary-Size" header gives the expected size of the binary data.  This is the size after any compressions, but before any ascii encodings.  This is useful in making a simple check for a missing portion of this file. The 8 bytes for the Compression type (see below) are not counted in this field, so the value of "X-Binary-Size" is 8 less than the quantity in bytes 12-19 of raw binary data ( 3.2.2 Format of CBF binary \par }\pard {\f20 sections). \par \par }\pard {\f20 The optional "Content-MD5" header provides a much more sophisticated check on the integrity of the binary data. Note that this check value is applied to the data after the 8 bytes for the Compression type. \par }\pard {\f20 \par }\pard {\f20 A blank line separator immediately precedes the start of the encoded binary data. Blank spaces may be added prior to the preceding "line separator" if desired (e.g. to force word or block alignment). \par }\pard {\f20 \par Because CBFLIB may jump forward in the file from the MIME header, the \par }\pard {\f20 length of encoded data cannot be greater than the value defined by "X-Binary-Size" (except when "X-Binary-Size" is zero, which means that the size is unknown). At exactly the byte following the full binary section as defined by the length value is the end of binary section identifier. This consists of the line-termination sequence followed by: \par }\pard {\f20 \par \par --CIF-BINARY-FORMAT-SECTION----\par ;\par \par \par }\pard {\f20 with each of these lines followed by a line-termination sequence. This brings us back into a normal CIF environment. This identifier is, in a sense, redundant because the binary data length value tells the a program how many bytes to jump over to the end of the binary data. This redundancy has been deliberately added for error checking, and for possible file recovery in the case of a corrupted file and this identifier must be present at the end of every block of binary data. \par }\pard {\f20 \par \par }{\b\f20 3.2.2 Format of CBF binary sections}{\f20 \par \par }\pard {\f20 In a CBF file, each binary section is encoded as a ;-delimited string, starting with an arbitrary number of pure-ASCII characters. \par }\pard {\f20 \par }\pard {\b\f20 Note:}{\f20  For historical reasons, CIFlib has the option of writing simple header and footer sections: "START OF BINARY SECTION" at the start of a binary section and "END OF BINARY SECTION" at the end of a binary section, or writing MIME-type header and footer sections (3.2.1 Format of imgCIF binary sections). If the simple header is used, the actual ASCII text is ignored when the binary section is read. Use of the simple binary header is deprecated. \par }\pard {\f20 \par The MIME header is recommended. \par \par }\pard {\f20 Between the ASCII header and the actual CBF binary data is a series of bytes ("octets") to try to stop the listing of the header, bytes which define the binary identifier which should match the "}{\i\f20 binary_id}{\f20 " defined in the header, and bytes which define the length of the binary section.\par }\pard {\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx1360\clshdng0\cellx2800\clshdng0\cellx4240\clshdng0\cellx8200\pard \intbl {\b\f20 Octet \cell Hex \cell Decimal \cell }\pard \intbl {\b\f20 Purpose \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx1360\clshdng0\cellx2800\clshdng0\cellx4240\clshdng0\cellx8200\pard \intbl {\f20 \~\~1 \cell \~\~0D \cell \~\~12 \cell }\pard \intbl {\f20 \~\~(ctrl-L) End of Page \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~2 \cell \~\~1A \cell \~\~26 \cell }\pard \intbl {\f20 \~\~(ctrl-Z) Stop listings in MS-DOS \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~3 \cell \~\~04 \cell \~\~04 \cell }\pard \intbl {\f20 \~\~(Ctrl-D) Stop listings in UNIX \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~4 \cell \~\~D5 \cell \~\~213 \cell }\pard \intbl {\f20 \~\~Binary section begins \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx1360\clshdng0\cellx2800\clshdng0\cellx4240\clshdng0\cellx8200\pard \intbl {\f20 \~\~5..5+n-1\cell \~\~\~\cell \~\~\~\cell }\pard \intbl {\f20 \~\~Binary data (n octets) \cell }\pard \intbl {\f20 \row }\pard {\f20 \par \par NOTE: When a MIME header is used, only bytes 5..5+n-1 are considered in \par }\pard {\f20 computing the size and the message digest, and only these bytes are encoded for the equivalent imgCIF file using the indicated Content-Transfer-Encoding. \par }\pard {\f20 \par }\pard {\f20 If no MIME header has been requested (a deprecated use), then bytes 5 through 28 are used for three 8-byte words to hold the }{\i\f20 binary_id}{\f20 , the size and the compression type: \par }\pard \keep\keepn {\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8560\pard \keep\keepn\intbl {\f20 \~\~5..12 \cell }\pard \keep\keepn\intbl {\f20 Binary Section Identifier (See _array_data.}{\i\f20 binary_id}{\f20 ) 64-bit, little endian \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8560\pard \intbl {\f20 \~\~13..20 \cell }\pard \intbl {\f20 The size (n) of the binary section in octets (i.e. the offset from octet 29 to the first byte following the data) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~21..28\cell }\pard \intbl {\f20 Compression type:\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx4960\clshdng0\cellx7480\pard \intbl {\f20 \cell \~\~CBF_NONE \cell \~\~0x0040 (64) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \cell \~\~CBF_CANONICAL \cell \~\~0x0050 (80) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \cell \~\~CBF_PACKED \cell \~\~0x0060 (96) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \cell \~\~CBF_BYTE_OFFSET \cell \~\~0x0070 (112) \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx4960\clshdng0\cellx7480\pard \intbl {\f20 \cell \~\~CBF_PREDICTOR \cell \~\~0x0080 (128) \cell }\pard \intbl {\f20 \row }\pard {\f20 \~\~... \tab \~\~\~\par \par The binary data then follows in bytes 29 through 29+n-1. \par \par The binary characters serve specific purposes: \par \par \par *\tab The Control-L (from-feed) will terminate printing of the current page on \par most operating systems. \par \par *\tab The Control-Z will stop the listing of the file on MS-DOS type operating \par systems. \par \par *\tab The Control-D will stop the listing of the file on Unix type operating systems. \par \par *\tab The unsigned byte value 213 (decimal) is binary 11010101. (Octal 325, \par }\pard {\f20 and hexadecimal D5). This has the eighth bit set so can be used for error checking on 7-bit transmission. It is also asymmetric, but with the first bit also set in the case that the bit order could be reversed (which is not a known concern). \par }\pard {\f20 \par *\tab (The carriage return, line-feed pair before the START_OF_BIN and other \par lines can also be used to check that the file has not been corrupted e.g. by being sent by ftp in ASCII mode.) \par \par \par \par }\pard {\f20 At present three compression schemes are implemented are defined: CBF_NONE (for no compression), CBF_CANONICAL (for and entropy-coding scheme based on the canonical-code algorithm described by Moffat, et al. (International Journal of High Speed Electronics and Systems, Vol 8, No 1 (1997) 179-231)) and CBF_PACKED for a CCP4-style packing scheme. Othercompression schemes will be added to this list in the future. \par }\pard {\f20 \par \par }\pard {\f20 For historical reasons, CBFlib can read or write a binary string without a MIME header. The structure of a binary string with simple headers is: \par }\pard {\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx1360\clshdng0\cellx2800\clshdng0\cellx4240\clshdng0\cellx8200\pard \intbl {\b\f20 Byte\cell ASCII Symbol\cell Decimal Value\cell }\pard \intbl {\b\f20 Description\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx1360\clshdng0\cellx2800\clshdng0\cellx4240\clshdng0\cellx8200\pard \intbl {\f20 \~\~1\cell \~\~;\cell \~\~59\cell }\pard \intbl {\f20 Initial ; delimiter\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~2\cell carriage-return\cell \~\~13\cell }\pard \intbl {\f20 The CBF new-line code is carriage-return, line-feed\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~3\cell line-feed\cell \~\~10\cell }\pard \intbl {\f20 \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~4\cell \~\~S\cell \~\~83\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~5\cell \~\~T\cell \~\~84\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~6\cell \~\~A\cell \~\~65\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~7\cell \~\~R\cell \~\~83\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~8\cell \~\~T\cell \~\~84\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~9\cell \~\~\cell \~\~32\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~10\cell \~\~O\cell \~\~79\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~11\cell \~\~F\cell \~\~70\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~12\cell \~\~\cell \~\~32\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~13\cell \~\~B\cell \~\~66\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~14\cell \~\~I\cell \~\~73\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~15\cell \~\~N\cell \~\~78\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~16\cell \~\~A\cell \~\~65\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~17\cell \~\~R\cell \~\~83\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~18\cell \~\~Y\cell \~\~89\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~19\cell \~\~\cell \~\~32\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~20\cell \~\~S\cell \~\~83\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~21\cell \~\~E\cell \~\~69\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~22\cell \~\~C\cell \~\~67\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~23\cell \~\~T\cell \~\~84\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~24\cell \~\~I\cell \~\~73\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~25\cell \~\~O\cell \~\~79\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~26\cell \~\~N\cell \~\~78\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~27\cell carriage-return\cell \~\~13\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~28\cell \~\~line-feed\cell \~\~10\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~29\cell \~\~form-feed\cell \~\~12\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~30\cell \~\~substitute\cell \~\~26\cell }\pard \intbl {\f20 Stop the listing of the file in MS-DOS\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~31\cell }\pard \intbl {\f20 \~\~end-of-transmission\cell }\pard \intbl {\f20 \~\~4\cell }\pard \intbl {\f20 Stop the listing of the file in unix\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~32\cell \~\~\cell \~\~213\cell }\pard \intbl {\f20 First non-ASCII value\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~33 .. 40\cell \~\~\cell \~\~\cell }\pard \intbl {\f20 Binary section identifier (64-bit little-endien)\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~41 .. 48\cell \~\~\cell \~\~\cell }\pard \intbl {\f20 Offset from byte 57 to the first ASCII character following the binary data\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~49 .. 56\cell \~\~\cell \~\~\cell }\pard \intbl {\f20 Compression type\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 57 .. 57+ n-1\cell \~\~\cell }\pard \intbl {\f20 Binary data (n bytes)\cell }\pard \intbl {\f20 \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~57 + n \cell \~\~carriage-return\cell \~\~13\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~58 + n \cell \~\~line-feed\cell \~\~10\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~59 + n \cell \~\~E\cell \~\~69\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~60 + n \cell \~\~N\cell \~\~78\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~61 + n \cell \~\~D\cell \~\~68\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~62 + n \cell \~\~\cell \~\~32\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~63 + n \cell \~\~O\cell \~\~79\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~64 + n \cell \~\~F\cell \~\~70\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~65 + n \cell \~\~\cell \~\~32\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~66 + n \cell \~\~B\cell \~\~66\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~67 + n \cell \~\~I\cell \~\~73\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~68 + n \cell \~\~N\cell \~\~78\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~69 + n \cell \~\~A\cell \~\~65\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~70 + n \cell \~\~R\cell \~\~83\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~71 + n \cell \~\~Y\cell \~\~89\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~72 + n \cell \~\~\cell \~\~32\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~73 + n \cell \~\~S\cell \~\~83\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~74 + n \cell \~\~E\cell \~\~69\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~75 + n \cell \~\~C\cell \~\~67\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~76 + n \cell \~\~T\cell \~\~84\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~77 + n \cell \~\~I\cell \~\~73\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~78 + n \cell \~\~O\cell \~\~79\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~79 + n \cell \~\~N\cell \~\~78\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~80 + n \cell \~\~carriage-return\cell \~\~13\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~81 + n \cell \~\~line-feed\cell \~\~10\cell }\pard \intbl {\f20 \~\~\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx1360\clshdng0\cellx2800\clshdng0\cellx4240\clshdng0\cellx8200\pard \intbl {\f20 \~\~82 + n \cell \~\~;\cell \~\~59\cell }\pard \intbl {\f20 Final ; delimiter\cell }\pard \intbl {\f20 \row }\pard {\b\f20 \par \par }\pard \keep\keepn {\b\f20 3.3 Compression schemes}{\f20 \par \par }\pard {\f20 Two schemes for lossless compression of integer arrays (such as images) have been implemented in this version of CBFlib: \par }\pard {\f20 \par 1. An entropy-encoding scheme using canonical coding\par 2. A CCP4-style packing scheme. \par \par }\pard {\f20 Both encode the difference (or error) between the current element in the array and the prior element. Parameters required for more sophisticated predictors have been included in the compression functions and will be used in a future version of the library. \par }\pard {\f20 \par }{\b\f20 3.3.1 Canonical-code compression}{\f20 \par \par }\pard {\f20 The canonical-code compression scheme encodes errors in two ways: directly or indirectly. Errors are coded directly using a symbol corresponding to the error value. Errors are coded indirectly using a symbol for the number of bits in the (signed) error, followed by the error iteslf. \par }\pard {\f20 \par }\pard {\f20 At the start of the compression, CBFlib constructs a table containing a set of symbols, one for each of the 2^}{\f20\up6 n}{\f20  direct codes from -2^}{\f20\up6 (n-1)}{\f20  .. 2^}{\f20\up6 (n-1)}{\f20 -1, one for a stop code, and one for each of the maxbits-n indirect codes, where n is chosen at compress time and maxbits is the maximum number of bits in an error. CBFlib then assigns to each symbol a bit-code, using a shorter bit code for the more common symbols and a longer bit code for the less common symbols. The bit-code lengths are calculated using a Huffman-type algorithm, and the actual bit-codes are constructed using the canonical-code algorithm described by Moffat, et al. (International Journal of High Speed Electronics and Systems, Vol 8, No 1 (1997) 179-231). \par }\pard {\f20 \par The structure of the compressed data is: \par \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx8200\pard \intbl {\b\f20 Byte\cell }\pard \intbl {\b\f20 Value \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx8200\pard \intbl {\f20 \~\~1 .. 8\cell }\pard \intbl {\f20 \~\~Number of elements (64-bit little-endian number)\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~9 .. 16\cell }\pard \intbl {\f20 \~\~Minimum element\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~17 .. 24\cell }\pard \intbl {\f20 \~\~Maximum element\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~25 .. 32\cell }\pard \intbl {\f20 \~\~(reserved for future use)\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~33\cell }\pard \intbl {\f20 \~\~Number of bits directly coded, n \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~34\cell }\pard \intbl {\f20 \~\~Maximum number of bits encoded, maxbits \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~35 .. 35+2}{\f20\up6 n}{\f20 -1\cell }\pard \intbl {\f20 \~\~Number of bits in each direct code\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~35+2}{\f20\up6 n}{\f20 \cell }\pard \intbl {\f20 \~\~Number of bits in the stop code\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~35+2}{\f20\up6 n}{\f20 +1 .. 35+2}{\f20\up6 n}{\f20 +maxbits-n \cell }\pard \intbl {\f20 \~\~Number of bits in each indirect code\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx8200\pard \intbl {\f20 \~\~35+2}{\f20\up6 n }{\f20 + \par }\pard \intbl {\f20 maxbits-n+1 .. \cell }\pard \intbl {\f20 \~\~Coded data\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20 3.3.2 CCP4-style compression}{\f20 \par \par }\pard {\f20 The CCP4-style compression writes the errors in blocks . Each block begins with a 6-bit code. The number of errors in the block is 2^n, where n is the value in bits 0 .. 2. Bits 3 .. 5 encode the number of bits in each error:\par }\pard {\f20 \par \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx4240\pard \qc\keep\keepn\intbl {\b\f20 Value in bits 3 .. 5\cell Number of bits\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx4240\pard \qc\keep\keepn\intbl {\b\f20 in each error\cell \cell }\pard \intbl {\f20 \row }\pard \qc\keep\keepn\intbl {\f20 0\cell 0\cell }\pard \intbl {\f20 \row }\pard \qc\keep\keepn\intbl {\f20 1\cell 4\cell }\pard \intbl {\f20 \row }\pard \qc\keep\keepn\intbl {\f20 2\cell 5\cell }\pard \intbl {\f20 \row }\pard \qc\keep\keepn\intbl {\f20 3\cell 6\cell }\pard \intbl {\f20 \row }\pard \qc\keep\keepn\intbl {\f20 4\cell 7\cell }\pard \intbl {\f20 \row }\pard \qc\keep\keepn\intbl {\f20 5\cell 8\cell }\pard \intbl {\f20 \row }\pard \qc\keep\keepn\intbl {\f20 6\cell 16\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx4240\pard \qc\keep\keepn\intbl {\f20 7\cell 65\cell }\pard \intbl {\f20 \row }\pard {\f20 \par The structure of the compressed data is:\par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx8200\pard \intbl {\b\f20 Byte\cell }\pard \intbl {\b\f20 Value\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx8200\pard \intbl {\f20 \~\~1 .. 8\cell }\pard \intbl {\f20 \~\~Number of elements (64-bit little-endian number)\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~9 .. 16\cell }\pard \intbl {\f20 \~\~Minumum element (currently unused)\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~17 .. 24\cell }\pard \intbl {\f20 \~\~Maximum element (currently unused)\cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~25 .. 32\cell }\pard \intbl {\f20 \~\~(reserved for future use)\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx8200\pard \intbl {\f20 \~\~33 ..\cell }\pard \intbl {\f20 \~\~Coded data\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }{\b\f20\fs28 \sect }\sectd \sbkodd\linemod0\linex0\cols1\endnhere \pard\plain \fs20 {\b\f20\fs28 4. Installation}{\f20 \par }\pard {\f20 \par \par }\pard {\f20 CBFlib should be built on a disk with at least 40 megabytes of free space. First create the top-level directory (called, say, CBFlib_0.7.2).   CBFlib_0.7.tar.gz is a \ldblquote gzipped\rdblquote  tar of the code as it now stands.  Uncompress this file, place it in the top level directory, and unpack it with tar: \par }\pard {\f20 \par      tar xvf CBFLIB_0.7.2.tar\par \par \par }\pard {\f20 To run the test programs, you will also need to put the MAR345 image example.mar2300 in the top-level directory.   The image can also be found at \par }\pard {\f20 \par http://biosg1.slac.stanford.edu/biosg1-users/ellis/Public/\par \par After unpacking the archive, the top-level directory should contain a makefile: \par \par \~\~Makefile\tab \~\~Makefile for unix \par \par and the subdirectories: \par \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 \~\~src/\cell }\pard \intbl {\f20 CBFLIB source files \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 \~\~include/\cell }\pard \intbl {\f20 CBFLIB header files \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~examples/\cell }\pard \intbl {\f20 Example program source files \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~doc/\cell }\pard \intbl {\f20 Documentation \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~lib/\cell }\pard \intbl {\f20 Compiled CBFLIB library \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 \~\~bin/\cell }\pard \intbl {\f20 Executable example programs \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 \~\~html_images/\cell }\pard \intbl {\f20 JPEG images used in rendering the HTML files \cell }\pard \intbl {\f20 \row }\pard {\f20 \par For instructions on compiling and testing the library, go to the top-level directory and type: \par \par      make\par \par The CBFLIB source and header files are in the "src" and "include" subdirectories. The files are: \par \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx4240\clshdng0\cellx8200\pard \intbl {\b\f20 src/\cell include/ \cell }\pard \intbl {\b\f20 Description \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx4240\clshdng0\cellx8200\pard \intbl {\f20 cbf.c\cell cbf.h \cell }\pard \intbl {\f20 Low-level CBFLIB API functions \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_simple.c\cell cbf_simple.h \cell }\pard \intbl {\f20 High-level CBFLIB API functions \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_alloc.c\cell cbf_alloc.h \cell }\pard \intbl {\f20 Memory allocation functions \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_ascii.c\cell cbf_ascii.h \cell }\pard \intbl {\f20 Function for writing ASCII values \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_binary.c\cell cbf_binary.h \cell }\pard \intbl {\f20 Functions for binary values \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_byte_offset.c\cell cbf_byte_offset.h \cell }\pard \intbl {\f20 Byte-offset compression (not implemented) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_canonical.c\cell cbf_canonical.h \cell }\pard \intbl {\f20 Canonical-code compression \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_codes.c\cell cbf_codes.h \cell }\pard \intbl {\f20 Encoding and message digest functions \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_compress.c\cell cbf_compress.h \cell }\pard \intbl {\f20 General compression routines \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_context.c\cell cbf_context.h \cell }\pard \intbl {\f20 Control of temporary files \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_file.c\cell cbf_file.h \cell }\pard \intbl {\f20 File in/out functions \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_lex.c\cell cbf_lex.h \cell }\pard \intbl {\f20 Lexical analyser \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_packed.c\cell cbf_packed.h \cell }\pard \intbl {\f20 CCP4-style packing compression \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_predictor.c\cell cbf_predictor.h \cell }\pard \intbl {\f20 Predictor-Huffman compression (not implemented) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_read_binary.c\cell cbf_read_binary.h \cell }\pard \intbl {\f20 Read binary headers \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_read_mime.c\cell cbf_read_mime.h \cell }\pard \intbl {\f20 Read MIME-encoded binary sections \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_string.c\cell cbf_string.h \cell }\pard \intbl {\f20 Case-insensitive string comparisons \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_stx.c\cell cbf_stx.h \cell }\pard \intbl {\f20 Parser \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_tree.c\cell cbf_tree.h \cell }\pard \intbl {\f20 CBF tree-structure functions \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_uncompressed.c\cell cbf_uncompressed.h \cell }\pard \intbl {\f20 Uncompressed binary sections \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_write.c\cell cbf_write.h \cell }\pard \intbl {\f20 Functions for writing \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_write_binary.c\cell cbf_write_binary.h \cell }\pard \intbl {\f20 Write binary sections \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf.stx\cell \~\~\~\cell }\pard \intbl {\f20 bison grammar to define cbf_stx.c (see WARNING) \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2080\clshdng0\cellx4240\clshdng0\cellx8200\pard \intbl {\f20 md5c.c\cell md5.h, global.h\cell }\pard \intbl {\f20 RSA message digest software from mpack \cell }\pard \intbl {\f20 \row }\pard {\f20 \par }\pard \tx10340 {\b\f20 WARNING:}{\f20   Do not rebuild the parser, cbf_stx.c, from the bison grammar, cbf.stx, unless absolutely necessary. There is a problem with the file bison.simple in the standard bison release. If you must rebuild cbf_stx.c using bison, you will need cbf_PARSER.simple as a replacement for bison.simple. See the cbf_PARSER.simple instructions.\par }\pard \tx10340 {\f20 \par }\pard \tx10340 {\f20 In the "examples" subdirectory, there are 2 additional files used by the example program (section 5) for reading MAR300, MAR345 or ADSC CCD images: \par }\pard {\f20 \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx4960\clshdng0\cellx8200\pard \intbl {\f20 img.c\cell img.h\cell }\pard \intbl {\f20 Simple image library \cell }\pard \intbl {\f20 \row }\pard {\f20 \par and the example programs themselves: \par \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 makecbf.c\cell }\pard \intbl {\f20 Make a CBF file from an image \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 img2cif.c\cell }\pard \intbl {\f20 Make an imgCIF or CBF from an image \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cif2cbf.c\cell }\pard \intbl {\f20 Copy a CIF/CBF to a CIF/CBF \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 convert_image.c\cell }\pard \intbl {\f20 Convert an image file to a cbf using a template file\cell }\pard \intbl {\f20 \row }\pard {\f20 \par }\pard {\f20 as well as two template files:  template_adscquantum4_2304x2304.cbf and template_mar345_2300x2300.cbf\par }\pard {\f20 \par The documentation files are in the "doc" subdirectory: \par \par }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 CBFlib.html\cell }\pard \intbl {\f20 This document (HTML) \cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 CBFlib.txt\cell }\pard \intbl {\f20 This document (ASCII) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 CBFlib_NOTICES.html\cell }\pard \intbl {\f20 Important NOTICES -- PLEASE READ \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 CBFlib_NOTICES.txt\cell }\pard \intbl {\f20 Important NOTICES -- PLEASE READ \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 CBFlib.ps\cell }\pard \intbl {\f20 CBFLIB manual (PostScript) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 CBFlib.pdf\cell }\pard \intbl {\f20 CBFLIB manual (PDF) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 CBFlib.rtf\cell }\pard \intbl {\f20 CBFLIB manual (RTF) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_definition_rev.txt\cell }\pard \intbl {\f20 Draft CBF/ImgCIF definition (ASCII) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cbf_definition_rev.html\cell }\pard \intbl {\f20 Draft CBF/ImgCIF definition (HTML) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cif_img_1.1.3.html\cell }\pard \intbl {\f20 Draft CBF/ImgCIF extensions dictionary (HTML) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 cif_img_1.1.3.dic\cell }\pard \intbl {\f20 Draft CBF/ImgCIF extensions dictionary (ASCII) \cell }\pard \intbl {\f20 \row }\pard \intbl {\f20 ChangeLog\cell }\pard \intbl {\f20 Summary of change history\cell }\pard \intbl {\f20 \row }\trowd \trgaph80\trleft-80 \clshdng0\cellx2440\clshdng0\cellx8200\pard \intbl {\f20 MANIFEST\cell }\pard \intbl {\f20 List of files in this kit \cell }\pard \intbl {\f20 \row }\pard {\f20 \par \sect }\sectd \sbkodd\linemod0\linex0\cols1\endnhere \pard\plain \fs20 {\b\f20 5. Example programs}{\f20 \par \par \par }\pard {\f20 The example programs makecbf.c and img2cif.c read an image file from a MAR300, MAR345 or ADSC CCD detector and then uses CBFlib to convert it to CBF format (makecbf) or either imgCIF or CBF format (img2cif).  makecbf writes the CBF-format image to disk, reads it in again, and then compares it to the original. img2cif just writes the desired file.  makecbf works only from stated files on disk, so that random I/O can be used. img2cif includes code to process files from stdin and to stdout. \par }\pard {\f20 \par }\pard {\f20 makecbf.c is a good example of how many of the CBFlib functions can be used. To compile makecbf on an alpha workstation running Digital unix or a Silicon Graphics workstation running irix (and on most other unix platforms as well), go to the src subdirectory of the main CBFlib directory and use the Makefile: \par }\pard {\f20 \par      make all\par \par \par An example MAR345 image can be found at: \par \par      http://biosg1.slac.stanford.edu/biosg1-users/ellis/Public/\par \par \par To run makecbf with the example image, type: \par \par      ./bin/makecbf example.mar2300 test.cbf\par \par \par The program img2cif has the following command line interface: \par                                                                  \par }{\f22  img2cif     [-i  input_image]                               \\\par              [-o  output_cif]                                \\\par              [-c  \{p[acked]|c[annonical]|[n[one]\}]           \\\par              [-m  \{h[eaders]|n[oheaders]\}]                   \\\par              [-d  \{d[igest]|n[odigest]\}]                     \\     \par              [-e  \{b[ase64]|q[uoted-printable]|              \\          \par                    d[ecimal]|h[exadecimal]|o[ctal]|n[one]\}]  \\      \par              [-b  \{f[orward]|b[ackwards]\}]                   \\ \par              [input_image] [output_cif]  \par }{\f20                                                                  \par  the options are:                                                \par                                                                  \par  -i  input_image (default: stdin)                                 \par      the input_image file in MAR300, MAR345 or ADSC CCD detector   \par      format is given.  If no input_image file is specified or is   \par      given as "-", an image is copied from stdin to a temporary file.\par                                                                  \par  -o  output_cif (default: stdout)                                 \par      the output cif (if base64 or quoted-printable encoding is used) \par      or cbf (if no encoding is used).  if no output_cif is specified \par      or is given as "-", the output is written to stdout           \par                                                                  \par  -c  compression_scheme (packed, canonical or none, default packed)\par                                                                  \par  -m  [no]headers (default headers for cifs, noheaders for cbfs)\par      selects MIME (N. Freed, N. Borenstein, RFC 2045, November 1996)\par      headers within binary data value text fields.\par                                                                  \par  -d  [no]digest  (default md5 digest [R. Rivest, RFC 1321, April\par      1992 using"RSA Data Security, Inc. MD5 Message-Digest\par      Algorithm"] when MIME headers are selected)\par                                                                  \par  -e  encoding (base64, quoted-printable, decimal, hexadecimal,    \par      octal or none, default: base64) specifies one of the standard \par      MIME encodings (base64 or quoted-printable) or a non-standard \par      decimal, hexamdecimal or octal encoding for an ascii cif      \par      or "none" for a binary cbf                                    \par                                                      \par  -b  direction (forward or backwards, default: backwards)         \par      specifies the direction of mapping of bytes into words        \par      for decimal, hexadecimal or octal output, marked by '>' for   \par      forward or '<' for backwards as the second character of each  \par      line of output, and in '#' comment lines.                     \par                                                                  \par \par \par \par }\pard {\f20 The test program cif2cbf uses the same command line options as img2cif, but accepts either a CIF or a CBF as input instead of an image file. \par }\pard {\f20 \par }\pard {\f20 The program convert_image take two arguments: }{\f22 imagefile}{\f20  and }{\f22 cbffile}{\f20 .  Those are the primary input and out.  The detector type is extracted from the image file, converted to lower case and used to construct the name of a template cbf file to use for the copy.  The template file name is of the form }{\f22 template_}{\i\f22 name}{\f22 _}{\i\f22 columns}{\f22 x}{\i\f22 rows.}{\f20 \par }\pard {\f20 \par \par }}